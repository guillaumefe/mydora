<!DOCTYPE html>
<html lang="en">
<head>
<style>

:root {
  --primary-50: #eff6ff;
  --primary-100: #dbeafe;
  --primary-200: #bfdbfe;
  --primary-500: #3b82f6;
  --primary-600: #2563eb;
  --primary-700: #1d4ed8;
  --gray-50: #f9fafb;
  --gray-100: #f3f4f6;
  --gray-200: #e5e7eb;
  --gray-300: #d1d5db;
  --gray-400: #9ca3af;
  --gray-500: #6b7280;
  --gray-600: #4b5563;
  --gray-700: #374151;
  --gray-900: #111827;
  --success-50: #ecfdf5;
  --success-500: #10b981;
  --success-600: #059669;
  --warning-50: #fffbeb;
  --warning-500: #f59e0b;
  --warning-600: #d97706;
  --danger-50: #fef2f2;
  --danger-500: #ef4444;
  --danger-600: #dc2626;
  --space-1: 0.25rem;
  --space-2: 0.5rem;
  --space-3: 0.75rem;
  --space-4: 1rem;
  --space-6: 1.5rem;
  --space-8: 2rem;
  --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
  --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1);
  --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1);
  --radius-sm: 0.375rem;
  --radius-md: 0.5rem;
  --radius-lg: 0.75rem;
}

* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

body {
  font-family: system-ui, -apple-system, sans-serif;
  line-height: 1.5;
  background-color: var(--gray-50);
  color: var(--gray-900);
  -webkit-font-smoothing: antialiased;
}


.container {
  width: 100%;
  padding: var(--space-4);
  margin: 0 auto;
}

@media (min-width: 640px) {
  .container {
    padding: var(--space-6);
  }
}

.card,
.regulation-item {
  background-color: white;
  border-radius: var(--radius-lg);
  padding: var(--space-4);
  margin-bottom: var(--space-4);
  border: 1px solid var(--gray-200);
  box-shadow: var(--shadow-sm);
  transition: box-shadow 0.2s ease;
}

.card:hover,
.regulation-item:hover {
  box-shadow: var(--shadow-md);
}

.header {
  margin-bottom: var(--space-6);
}

.title {
  font-size: 1.5rem;
  font-weight: 600;
  color: var(--gray-900);
  margin-bottom: var(--space-2);
}

.compliance-rate {
  font-size: 1.125rem;
  color: var(--primary-600);
  font-weight: 500;
  margin-bottom: var(--space-4);
}

.import-export-bar {
  display: flex;
  flex-wrap: wrap;
  gap: var(--space-2);
  background-color: var(--primary-50);
  padding: var(--space-3);
  border-radius: var(--radius-md);
  margin-bottom: var(--space-4);
}

.search-container {
  margin-bottom: var(--space-4);
}

.input {
  width: 100%;
  padding: var(--space-3) var(--space-4);
  border: 1px solid var(--gray-200);
  border-radius: var(--radius-md);
  font-size: 1rem;
  transition: all 0.2s ease;
}

.input:focus {
  outline: none;
  border-color: var(--primary-500);
  box-shadow: 0 0 0 2px var(--primary-100);
}

.button,
.action-buttons .button {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  padding: var(--space-2) var(--space-4);
  border-radius: var(--radius-md);
  font-weight: 500;
  font-size: 0.875rem;
  transition: all 0.2s ease;
  cursor: pointer;
  border: none;
  background-color: var(--primary-600);
  color: white;
  gap: var(--space-2);
}

.button:hover,
.action-buttons .button:hover {
  background-color: var(--primary-700);
}

.button.secondary,
.button.secondary:hover {
  background-color: var(--gray-100);
  color: var(--gray-700);
}

.tabs,
.raci-grid {
  display: flex;
  overflow-x: auto;
  gap: var(--space-2);
  margin-bottom: var(--space-4);
  -webkit-overflow-scrolling: touch;
  scrollbar-width: none;
  padding-bottom: var(--space-2);
}

.tabs::-webkit-scrollbar {
  display: none;
}

.tab {
  padding: var(--space-2) var(--space-4);
  background-color: var(--gray-100);
  border-radius: var(--radius-md);
  font-size: 0.875rem;
  font-weight: 500;
  color: var(--gray-700);
  white-space: nowrap;
  cursor: pointer;
  transition: all 0.2s ease;
}

.tab.active {
  background-color: var(--primary-600);
  color: white;
}

.add-article-container,
.section-container {
  background-color: white;
  border-radius: var(--radius-lg);
  margin-bottom: var(--space-4);
  overflow: hidden;
  border: 1px solid var(--gray-200);
}

.form-header,
.section-header {
  background-color: var(--primary-600);
  color: white;
  padding: var(--space-4);
  cursor: pointer;
  display: flex;
  justify-content: space-between;
  align-items: center;
  font-weight: 500;
}

.form-content,
.section-content {
  max-height: 0;
  overflow: hidden;
  transition: max-height 0.3s ease-out;
}

.form-content.visible,
.section-content {
  max-height: 2000px;
  padding: var(--space-4);
}

.form-group,
.remediation-actions {
  margin-bottom: var(--space-4);
}

.form-group label,
.raci-label {
  display: block;
  margin-bottom: var(--space-2);
  font-weight: 500;
  color: var(--gray-700);
}

.regulation-header,
.action-header,
.actions-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: var(--space-3);
}

.action-item,
.remediation-item,
.risk-item {
  background-color: var(--gray-50);
  border-radius: var(--radius-md);
  padding: var(--space-3);
  margin-bottom: var(--space-3);
  border: 1px solid var(--gray-200);
  overflow: hidden;
}

.save-status {
  position: fixed;
  bottom: var(--space-4);
  right: var(--space-4);
  background-color: var(--success-500);
  color: white;
  padding: var(--space-3) var(--space-4);
  border-radius: var(--radius-md);
  font-weight: 500;
  opacity: 0;
  transform: translateY(1rem);
  transition: all 0.3s ease;
  box-shadow: var(--shadow-lg);
}

.save-status.visible {
  opacity: 1;
  transform: translateY(0);
}

.button-group,
.category-controls,
.header-content {
  display: flex;
  gap: var(--space-2);
  align-items: center;
}

.config-label {
  display: flex;
  flex-direction: column;
  gap: var(--space-1);
}


</style>

</style>
</head>
<body>
<div class="container">
    <div class="add-article-container">
        <div class="form-header" onclick="toggleForm()">
            <span>Ajouter un nouvel article</span>
            <span id="form-toggle">▼</span>
        </div>
        <div class="form-content" id="articleForm">
            <div class="form-group">
                <label for="articleCategory">Catégorie</label>
                <select id="articleCategory" class="input" onchange="toggleConditionalFields()">
                    <option value="">Sélectionnez une catégorie</option>
                    <option value="Level 1">Level 1</option>
                    <option value="RTS">RTS</option>
                    <option value="ITS">ITS</option>
                </select>
            </div>
            <div class="form-group">
                <label for="articleReference">Référence</label>
                <input type="text" id="articleReference" class="input" placeholder="ex: L1-1, RTS-1, ITS-1">
            </div>
            <div class="form-group">
                <label for="articleText">Texte de l'article</label>
                <textarea id="articleText" class="input" placeholder="Entrez le texte de l'article"></textarea>
            </div>
            <div class="conditional-fields" id="level1Fields">
                <div class="form-group">
                    <label for="rtsLink">RTS associée(s)</label>
                    <input type="text" id="rtsLink" class="input" placeholder="ex: RTS-1, RTS-2">
                </div>
                <div class="form-group">
                    <label for="itsLink">ITS associée(s)</label>
                    <input type="text" id="itsLink" class="input" placeholder="ex: ITS-1, ITS-2">
                </div>
            </div>

<div class="conditional-fields" id="rtsItsFields">
                <div class="form-group">
                    <label for="level1Link">Article Level 1 associé</label>
                    <input type="text" id="level1Link" class="input" placeholder="ex: L1-1">
                </div>
            </div>
            <div class="error-message" id="formError"></div>
            <button class="button" onclick="addNewArticle()">Ajouter l'article</button>
        </div>
    </div>
    <div class="card header">
        <h1 class="title">Suivi de Conformité DORA</h1>
        <div class="compliance-rate">Taux de conformité: 0.0%</div>
        <div class="import-export-bar">
            <button class="button secondary" onclick="exportData()">Exporter</button>
            <button class="button secondary" onclick="document.getElementById('importInput').click()">Importer</button>
            <input type="file" id="importInput" style="display: none" onchange="importData(event)">
            <button class="button secondary" onclick="resetAll()">Reset All</button>
            <button class="button secondary" onclick="exportProject()">Export Projet</button>
        </div>
        <div class="search-container">
            <input type="text" class="input" id="searchInput" placeholder="Rechercher un article...">
        </div>
        <div class="tabs" id="statusTabs">
            <div class="tab active" data-status="all" onclick="handleStatusTabClick(event)">Tous</div>
            <div class="tab" data-status="A faire" onclick="handleStatusTabClick(event)">A faire</div>
            <div class="tab" data-status="En cours" onclick="handleStatusTabClick(event)">En cours</div>
            <div class="tab" data-status="Compliant" onclick="handleStatusTabClick(event)">Compliant</div>
            <div class="tab" data-status="Non Applicable" onclick="handleStatusTabClick(event)">Non Applicable</div>
            <div class="tab" data-status="Documentation" onclick="handleStatusTabClick(event)">Documentation</div>
            <div class="tab" data-status="Exigences with Risks" onclick="handleStatusTabClick(event)">Actions avec Risques</div>
        </div>
        <div class="filters" id="categoryFilters">
            <span class="category-filter active" data-category="all">Tous</span>
            <span class="category-filter" data-category="Level 1">Level 1</span>
            <span class="category-filter" data-category="RTS">RTS</span>
            <span class="category-filter" data-category="ITS">ITS</span>
        </div>
        <div class="toggle-visibility" id="toggleVisibility" style="display: none;">
            <label><input type="checkbox" id="showCompliant" checked onchange="renderRegulations()"> Compliant</label>
            <label><input type="checkbox" id="showNonApplicable" checked onchange="renderRegulations()"> Non Applicable</label>
            <label><input type="checkbox" id="showDocumentation" checked onchange="renderRegulations()"> Documentation</label>
        </div>
        <span class="save-status" id="saveStatus">Modifications sauvegardées</span>
    </div>
    <div id="wallItems"></div>
    <div id="regulationsList"></div>

</div>
</div>

<script src="https://cdn.sheetjs.com/xlsx-latest/package/dist/shim.min.js"></script>
<script src="https://cdn.sheetjs.com/xlsx-latest/package/dist/xlsx.full.min.js"></script>



<!-- Ajouter dans le head de votre HTML, avant vos autres scripts -->
<script src="https://www.gstatic.com/firebasejs/10.7.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.7.0/firebase-firestore-compat.js"></script>






<script>


// Variables pour le lazy loading
let lastDoc = null;
let isLoading = false;
const BATCH_SIZE = 10;


// Recherche et filtrage
async function searchAndFilter(searchTerm, filter, status) {
    let query = db.collection('regulations');

    if (filter !== 'all') {
        query = query.where('category', '==', filter);
    }
    if (status !== 'all') {
        query = query.where('status', '==', status);
    }

    query = query.limit(BATCH_SIZE);

    try {
        const snapshot = await query.get();
        const regulations = snapshot.docs.map(doc => ({
            id: doc.id,
            ...doc.data()
        }));

        // Filtrage texte côté client
        const filtered = searchTerm ? regulations.filter(reg => 
            reg.text.toLowerCase().includes(searchTerm.toLowerCase()) ||
            reg.id.toLowerCase().includes(searchTerm.toLowerCase())
        ) : regulations;

        renderBatch(filtered, true);
    } catch (error) {
        console.error("Erreur de recherche:", error);
    }
}

// Fonction principale de rendu des lots
function renderBatch(data) {
    const { items, total, hasMore, startIndex } = data;
    const container = document.getElementById('wallItems');
    
    // Si c'est le premier lot, nettoyer le conteneur
    if (startIndex === 0) {
        container.innerHTML = '';
    }

    // Vérifier si items est un tableau
    if (!Array.isArray(items)) {
        console.error('Items n\'est pas un tableau:', items);
        return;
    }

    // Rendre chaque élément
    items.forEach(reg => {
        const articleElement = document.createElement('div');
        articleElement.className = 'regulation-item fade-in';
        articleElement.id = `regulation-${reg.id}`;
        articleElement.innerHTML = renderRegulationContent(reg);
        container.appendChild(articleElement);
    });

    // Gérer le bouton "Charger plus"
    if (hasMore) {
        appendLoadMoreButton(container);
    }

    // Mettre à jour les statistiques
    updateStats(total);
}

function updateStats(total) {
    const statsElement = document.querySelector('.compliance-rate');
    if (statsElement) {
        const visibleItems = document.querySelectorAll('.regulation-item').length;
        statsElement.textContent = `Affichage de ${visibleItems} sur ${total} éléments`;
    }
}

function appendLoadMoreButton(container) {
    let button = container.querySelector('.load-more');
    if (!button) {
        button = document.createElement('button');
        button.className = 'button load-more';
        button.textContent = 'Charger plus';
        button.onclick = () => loadRegulations(false);
        container.appendChild(button);
    }
}

// Configuration de l'Intersection Observer
function setupIntersectionObserver() {
    const observer = new IntersectionObserver(entries => {
        entries.forEach(entry => {
            if (entry.isIntersecting && !isLoading && lastDoc) {
                loadRegulations(false);
            }
        });
    }, {
        rootMargin: '100px'
    });

    let sentinel = document.querySelector('.load-sentinel');
    if (!sentinel) {
        sentinel = document.createElement('div');
        sentinel.className = 'load-sentinel';
        document.getElementById('wallItems').appendChild(sentinel);
    }

    observer.observe(sentinel);
}

// CRUD Operations
async function addRegulation(regulation) {
    try {
        await db.collection('regulations').add(regulation);
        loadRegulations(true);
    } catch (error) {
        console.error("Erreur d'ajout:", error);
    }
}

async function updateRegulation(id, updates) {
    try {
        await db.collection('regulations').doc(id).update(updates);
    } catch (error) {
        console.error("Erreur de mise à jour:", error);
    }
}

async function deleteRegulation(id) {
    try {
        await db.collection('regulations').doc(id).delete();
        loadRegulations(true);
    } catch (error) {
        console.error("Erreur de suppression:", error);
    }
}

// Migration des données existantes
async function migrateToFirebase() {
    if (!confirm('Voulez-vous migrer les données vers Firebase ?')) return;

    try {
        const batch = db.batch();
        let count = 0;

        for (const reg of regulations) {
            const docRef = db.collection('regulations').doc();
            batch.set(docRef, reg);
            count++;

            // Firebase limite les batches à 500 opérations
            if (count === 499) {
                await batch.commit();
                count = 0;
            }
        }

        if (count > 0) {
            await batch.commit();
        }

        alert('Migration terminée');
    } catch (error) {
        console.error('Erreur de migration:', error);
        alert('Erreur pendant la migration');
    }
}

// Modification des gestionnaires d'événements existants
function handleSearchInput(event) {
    searchAndFilter(event.target.value, activeFilter, activeStatus);
}

function handleCategoryFilter(event) {
    if (event.target.classList.contains('category-filter')) {
        document.querySelectorAll('.category-filter')
            .forEach(filter => filter.classList.remove('active'));
        event.target.classList.add('active');
        activeFilter = event.target.dataset.category;
        searchAndFilter(
            document.getElementById('searchInput').value,
            activeFilter,
            activeStatus
        );
    }
}

function handleStatusTabClick(event) {
    if (event.target.classList.contains('tab')) {
        document.querySelectorAll('.tab')
            .forEach(tab => tab.classList.remove('active'));
        event.target.classList.add('active');
        activeStatus = event.target.dataset.status;
        searchAndFilter(
            document.getElementById('searchInput').value,
            activeFilter,
            activeStatus
        );
    }
}

// Initialisation
document.addEventListener('DOMContentLoaded', () => {
    loadRegulations(true);
});


let regulations = [];
let activeFilter = 'all';
let activeStatus = 'all';

function initializeRegulations() {
    return [];
}

function renderWallItems() {
    const wallItemsContainer = document.getElementById('wallItems');
    wallItemsContainer.innerHTML = '';

    regulations.forEach(reg => {
        reg.actions.forEach(action => {
            const wallItem = document.createElement('div');
            wallItem.classList.add('wall-item');

            wallItem.innerHTML = `
                <h3>${action.text}</h3>®
                <button onclick="confirmDeleteAction('${reg.id}', ${action.id})">Supprimer</button>
                <button onclick="addRiskPrompt('${reg.id}', ${action.id})">Ajouter un Risque</button>
                <div id="risks-${action.id}"></div>
            `;

            renderRisks(reg.id, action.id, wallItem);

            wallItemsContainer.appendChild(wallItem);
        });
    });
}

function toggleForm() {
    const formContent = document.getElementById('articleForm');
    const formToggle = document.getElementById('form-toggle');
    formContent.classList.toggle('visible');
    formToggle.textContent = formContent.classList.contains('visible') ? '▲' : '▼';
}

function addActionPrompt() {
    const actionText = prompt("Entrez la description de l'action :");
    if (actionText) {
        addAction(actionText);
        renderActions();
    }
}

function toggleConditionalFields() {
    const category = document.getElementById('articleCategory').value;
    const level1Fields = document.getElementById('level1Fields');
    const rtsItsFields = document.getElementById('rtsItsFields');
    level1Fields.classList.remove('visible');
    rtsItsFields.classList.remove('visible');
    if (category === 'Level 1') {
        level1Fields.classList.add('visible');
    } else if (category === 'RTS' || category === 'ITS') {
        rtsItsFields.classList.add('visible');
    }
}

function renderLinks(article) {
    if (!article) return '';
    let linksHtml = '';
    if (article.category === 'Level 1') {
        if (Array.isArray(article.rtsLinks) && article.rtsLinks.length > 0) {
            linksHtml += `<div class="regulation-links"><div>RTS associée(s): ${article.rtsLinks.join(', ')}</div></div>`;
        }
        if (Array.isArray(article.itsLinks) && article.itsLinks.length > 0) {
            linksHtml += `<div class="regulation-links"><div>ITS associée(s): ${article.itsLinks.join(', ')}</div></div>`;
        }
    } else if (article.category !== 'Level 1' && article.level1Link) {
        linksHtml += `<div class="regulation-links">Article Level 1 associé: ${article.level1Link}</div>`;
    }
    return linksHtml;
}

function renderActions(reg) {
    if (!reg || !Array.isArray(reg.actions)) return '';

    return reg.actions.map(action => {
        const isCollapsed = action.isCollapsed || false;
        return `
            <div class="action-item ${isCollapsed ? 'collapsed' : ''}" id="action-${action.id}">
                <div class="action-header">
                    <div class="action-title">
                        <button class="toggle-button" onclick="toggleAction('${reg.id}', ${action.id})">
                            ${isCollapsed ? '▸' : '▾'}
                        </button>
                        <span class="action-text">${action.text || ''}</span>
                    </div>
                    <div class="action-buttons">
                        <button class="button secondary" onclick="removeAction('${reg.id}', ${action.id})">
                            Supprimer
                        </button>
                        <button class="button secondary" onclick="addRiskPrompt('${reg.id}', ${action.id})">
                            Ajouter un Risque
                        </button>
                    </div>
                </div>
                <div class="action-content">
                    <div class="risks-container">
                        ${renderRisks(reg.id, action.id)}
                    </div>
                </div>
            </div>
        `;
    }).join('');
}
function renderActions(reg) {
    if (!reg || !Array.isArray(reg.actions)) return '';

    return reg.actions.map(action => {
        const isCollapsed = action.isCollapsed || false;
        return `
            <div class="action-item ${isCollapsed ? 'collapsed' : ''}" id="action-${action.id}">
                <div class="action-header">
                    <div class="action-title">
                        <button class="toggle-button" onclick="toggleAction('${reg.id}', ${action.id})">
                            ${isCollapsed ? '▸' : '▾'}
                        </button>
                        <span class="action-text">${action.text || ''}</span>
                    </div>
                    <div class="action-buttons">
                        <button class="button secondary" onclick="removeAction('${reg.id}', ${action.id})">
                            Supprimer
                        </button>
                        <button class="button secondary" onclick="addRiskPrompt('${reg.id}', ${action.id})">
                            Ajouter un Risque
                        </button>
                    </div>
                </div>
                <div class="action-content">
                    <div class="form-group">
                        <label for="percentage-${action.id}">Pourcentage d'avancement:</label>
                        <input type="number" id="percentage-${action.id}" class="input" min="0" max="100" value="${action.percentage}" onchange="updateActionPercentage('${reg.id}', ${action.id}, this.value)">
                    </div>
                    <div class="action-progress-bar">
                        <div class="action-progress-fill" style="width: ${action.percentage}%; background-color: ${getProgressBarColor(action.percentage)};"></div>
                    </div>
                    <div class="raci-container">
                        <h5>RACI</h5>
                        <div class="raci-group">
                            <label for="action-responsible-${action.id}">Responsable (R):</label>
                            <input type="text" id="action-responsible-${action.id}" class="input" value="${action.raci.responsible}" placeholder="Responsable" onchange="updateActionRACI('${reg.id}', ${action.id}, 'responsible', this.value)">
                        </div>
                        <div class="raci-group">
                            <label for="action-accountable-${action.id}">Autorité (A):</label>
                            <input type="text" id="action-accountable-${action.id}" class="input" value="${action.raci.accountable}" placeholder="Autorité" onchange="updateActionRACI('${reg.id}', ${action.id}, 'accountable', this.value)">
                        </div>
                        <div class="raci-group">
                            <label for="action-consulted-${action.id}">Consultés (C):</label>
                            <input type="text" id="action-consulted-${action.id}" class="input" value="${action.raci.consulted}" placeholder="Consultés" onchange="updateActionRACI('${reg.id}', ${action.id}, 'consulted', this.value)">
                        </div>
                        <div class="raci-group">
                            <label for="action-informed-${action.id}">Informés (I):</label>
                            <input type="text" id="action-informed-${action.id}" class="input" value="${action.raci.informed}" placeholder="Informés" onchange="updateActionRACI('${reg.id}', ${action.id}, 'informed', this.value)">
                        </div>
                    </div>
                    <div class="risks-container">
                        ${renderRisks(reg.id, action.id)}
                    </div>
                </div>
            </div>
        `;
    }).join('');
}


function updateActionPercentage(regulationId, actionId, value) {
    const percentage = Math.min(Math.max(parseInt(value), 0), 100); // Ensure 0 <= percentage <= 100
    regulations = regulations.map(reg => {
        if (reg.id === regulationId) {
            return {
                ...reg,
                actions: reg.actions.map(action =>
                    action.id === actionId
                        ? { ...action, percentage }
                        : action
                )
            };
        }
        return reg;
    });
    renderRegulations();
    autoSave();
}

function updateActionRACI(regulationId, actionId, raciType, value) {
    regulations = regulations.map(reg => {
        if (reg.id === regulationId) {
            return {
                ...reg,
                actions: reg.actions.map(action =>
                    action.id === actionId
                        ? { 
                            ...action, 
                            raci: { 
                                ...action.raci, 
                                [raciType]: value 
                            } 
                          }
                        : action
                )
            };
        }
        return reg;
    });
    autoSave();
}


function toggleAction(regulationId, actionId) {
    regulations = regulations.map(reg => {
        if (reg.id === regulationId) {
            return {
                ...reg,
                actions: reg.actions.map(action => {
                    if (action.id === actionId) {
                        return {
                            ...action,
                            isCollapsed: !action.isCollapsed
                        };
                    }
                    return action;
                })
            };
        }
        return reg;
    });

    // Mettre à jour visuellement sans re-render complet
    const actionElement = document.getElementById(`action-${actionId}`);
    if (actionElement) {
        actionElement.classList.toggle('collapsed');
        const toggleButton = actionElement.querySelector('.toggle-button');
        const actionContent = actionElement.querySelector('.action-content');
        if (actionElement.classList.contains('collapsed')) {
            toggleButton.textContent = '▸';
            actionContent.style.maxHeight = '0px';
        } else {
            toggleButton.textContent = '▾';
            actionContent.style.maxHeight = actionContent.scrollHeight + 'px';
        }
    }
    
    autoSave();
}

// Ajouter un bouton global pour plier/déplier toutes les tâches
function addGlobalToggleButton() {
    const actionsContainer = document.querySelector('.actions-container h4');
    if (actionsContainer) {
        actionsContainer.innerHTML = `
            <div class="actions-header">
                <span>Actions associées</span>
                <button class="button secondary" onclick="toggleAllActions(this)">
                    Tout plier
                </button>
            </div>
        `;
    }
}

function toggleAllActions(button) {
    const isCollapsing = button.textContent.includes('plier');
    
    regulations = regulations.map(reg => ({
        ...reg,
        actions: reg.actions.map(action => ({
            ...action,
            isCollapsed: isCollapsing
        }))
    }));

    // Mettre à jour le texte du bouton
    button.textContent = isCollapsing ? 'Tout déplier' : 'Tout plier';

    // Mettre à jour l'affichage
    renderRegulations();
    autoSave();
}

function confirmDeleteAction(regulationId, actionId) {
    if (confirm("Êtes-vous sûr de vouloir supprimer cette action ?")) {
        removeAction(regulationId, actionId);
    }
}

function getProgressColor(action) {
    if (!action.risks || action.risks.length === 0) {
        return 'var(--success-color)';
    }
    const maxRisk = Math.max(...action.risks.map(r => r.level));
    if (maxRisk <= 4) return 'var(--success-color)';
    if (maxRisk <= 8) return 'var(--warning-color)';
    return 'var(--danger-color)';
}

function renderProofLinks(reg) {
    if (!reg.proofLinks || reg.proofLinks.length === 0) return '';
    return `
        <div class="proof-links">
            <strong>Liens de matérialité:</strong>
            <ul>
                ${reg.proofLinks.map((link, index) => `
                    <li>
                        <a href="${link}" target="_blank">${link}</a>
                        <button class="button secondary" onclick="deleteProofLink('${reg.id}', ${index})">Supprimer</button>
                    </li>
                `).join('')}
            </ul>
        </div>
    `;
}

function renderJustification(reg) {
    if (reg.status !== 'Non Applicable') return '';
    return `
        <div class="justification-input-container">
            <input type="text" class="input" id="justification-input-${reg.id}" placeholder="Ajouter une justification...">
            <button class="button" onclick="addJustification('${reg.id}')">Ajouter</button>
        </div>
        ${renderJustificationList(reg)}
    `;
}

function renderJustificationList(reg) {
    if (!reg.justifications || reg.justifications.length === 0) return '';
    return `
        <div class="justification-list">
            ${reg.justifications.map((justification, index) => `
                <div class="justification-item">
                    <span>${justification.text}</span>
                    <span>${new Date(justification.timestamp).toLocaleString()}</span>
                    <button class="button secondary" onclick="deleteJustification('${reg.id}', ${index})">Supprimer</button>
                </div>
            `).join('')}
        </div>
    `;
}

function getProgressBarColor(percentage) {
    if (percentage >= 80) return 'var(--success-500)';
    if (percentage >= 50) return 'var(--warning-500)';
    return 'var(--danger-500)';
}


function filterRegulation(reg) {
    const searchTerm = document.getElementById('searchInput').value.toLowerCase();

    // Filtrage basé sur la recherche
    if (searchTerm) {
        const inRegText = reg.text.toLowerCase().includes(searchTerm);
        const inRegId = reg.id.toLowerCase().includes(searchTerm);
       
        const inActions = reg.actions.some(action => {
            const inActionText = action.text.toLowerCase().includes(searchTerm);
            const inAssignedTo = action.assignedTo && action.assignedTo.toLowerCase().includes(searchTerm);
            const inResponsible = action.raci && action.raci.responsible && action.raci.responsible.toLowerCase().includes(searchTerm);
            const inRiskDescription = action.risks && action.risks.some(risk => risk.description && risk.description.toLowerCase().includes(searchTerm));
            return inActionText || inAssignedTo || inResponsible || inRiskDescription;
        });
       
        if (!inRegText && !inRegId && !inActions) {
            return false;
        }
    }

    // Filtrage basé sur les filtres de catégorie
    if (activeFilter !== 'all') {
        return reg[activeFilter];
    }

    // Filtrage basé sur les filtres de statut existants
    if (activeStatus === 'A faire') {
        const totalProgress = reg.actions.reduce((sum, action) => sum + (action.percentage || 0), 0);
        if (totalProgress > 0) return false;
    } else if (activeStatus === 'En cours') {
        const totalProgress = reg.actions.reduce((sum, action) => sum + (action.percentage || 0), 0);
        if (totalProgress === 0) return false;
    } else if (activeStatus === 'all') {
        const showCompliant = document.getElementById('showCompliant').checked;
        const showNonApplicable = document.getElementById('showNonApplicable').checked;
        const showDocumentation = document.getElementById('showDocumentation').checked;
        if ((reg.status === 'Compliant' && !showCompliant) ||
            (reg.status === 'Non Applicable' && !showNonApplicable) ||
            (reg.status === 'Documentation' && !showDocumentation)) {
            return false;
        }
    } else if (activeStatus !== 'all' && reg.status !== activeStatus) {
        return false;
    }

    return true;
}



function calculateCompliance(regList) {
    let totalCompliance = 0;
    let totalApplicable = 0;
    regList.forEach(reg => {
        if (reg.status === 'Non Applicable' || reg.status === 'Documentation') return;
        totalApplicable++;
        if (reg.status === 'Compliant') {
            totalCompliance += 100;
        } else {
            if (reg.actions.length > 0) {
                let totalActionProgress = reg.actions.reduce((sum, action) => sum + (action.percentage || 0), 0);
                let averageProgress = totalActionProgress / reg.actions.length;
                totalCompliance += averageProgress;
            }
        }
    });
    return totalApplicable ? (totalCompliance / totalApplicable).toFixed(1) : '0.0';
}


// Helper function pour isoler le rendu du contenu d'une régulation
function renderRegulationContent(reg) {
    return `
        <div class="regulation-header">
            <!-- Code HTML existant pour regulation-header -->
            <label>
                <input type="radio" 
                    name="status-${reg.id}" 
                    class="checkbox" 
                    value="Compliant" 
                    ${reg.status === 'Compliant' ? 'checked' : ''} 
                    onchange="updateStatus('${reg.id}', 'Compliant')"> Compliant
            </label>
            <!-- Autres radios... -->
        </div>
        <div class="regulation-content">
            <div class="regulation-text">${reg.text}</div>
            <div class="regulation-id"><i>${reg.id}</i></div>
            ${renderLinks(reg)}
            ${renderRACI(reg)}
            ${renderActions(reg)}
            ${renderJustification(reg)}
            ${renderProofLinks(reg)}
            
            <div class="action-buttons">
                <button class="button secondary" onclick="editRegulation('${reg.id}')">Éditer</button>
                <button class="button secondary" onclick="deleteRegulation('${reg.id}')">Supprimer</button>
            </div>
        </div>
    `;
}



// Ajout des variables pour le lazy loading
let currentPage = 1;
const ITEMS_PER_PAGE = 20;
let hasMore = true;

// Modification de la fonction renderRegulations pour supporter le lazy loading
function renderRegulations(reset = false) {
    const regulationsList = document.getElementById('wallItems');
    const complianceRate = document.querySelector('.compliance-rate');
    
    // Réinitialisation si demandée
    if (reset) {
        regulationsList.innerHTML = '';
        currentPage = 1;
        hasMore = true;
    }

    // Filtrer les réglementations
    let filteredRegs = regulations.filter(filterRegulation);
    
    // Calculer le taux de conformité
    let compliancePercentage = calculateCompliance(filteredRegs);
    complianceRate.textContent = `Taux de conformité: ${compliancePercentage}%`;

    if (filteredRegs.length === 0) {
        regulationsList.innerHTML = '<div>Aucune exigence trouvée</div>';
        return;
    }

    // Calculer la plage d'éléments à afficher
    const start = (currentPage - 1) * ITEMS_PER_PAGE;
    const end = start + ITEMS_PER_PAGE;
    const regsToRender = filteredRegs.slice(start, end);
    hasMore = end < filteredRegs.length;

    // Rendre les éléments
    regsToRender.forEach(reg => {
        regulationsList.innerHTML += `
            <div class="regulation-item" id="regulation-${reg.id}">
                <!-- Code HTML existant pour regulation-item -->
                ${renderRegulationContent(reg)}
            </div>
        `;
    });

    // Ajouter un élément observateur pour l'infinite scroll
    if (hasMore) {
        const observer = new IntersectionObserver((entries) => {
            if (entries[0].isIntersecting && !isLoading) {
                loadMoreRegulations();
            }
        }, {
            rootMargin: '100px',
        });

        const sentinel = document.createElement('div');
        sentinel.className = 'loading-sentinel';
        regulationsList.appendChild(sentinel);
        observer.observe(sentinel);
    }
}
function renderRegulations(reset = false) {
    const regulationsList = document.getElementById('wallItems');
    const complianceRate = document.querySelector('.compliance-rate');
    
    // Si reset, réinitialiser la page et le conteneur
    if (reset) {
        currentPage = 1;
        regulationsList.innerHTML = '';
    }

    // Calculer les index de début et de fin pour ce lot
    const startIndex = (currentPage - 1) * 10;
    const endIndex = startIndex + 10;
    
    // Prendre seulement les 10 éléments concernés
    const currentBatch = regulations.slice(startIndex, endIndex);

    // Filtrer uniquement ce petit lot
    const filteredBatch = currentBatch.filter(filterRegulation);
    
    // Gérer le cas où il n'y a pas de données
    if (regulations.length === 0) {
        regulationsList.innerHTML = '<div>Aucune exigence trouvée</div>';
        return;
    }

    // Rendre uniquement les éléments filtrés de ce lot
    filteredBatch.forEach(reg => {
        regulationsList.innerHTML += `
            <div class="regulation-item" id="regulation-${reg.id}">
                <div class="regulation-header">
                    <label>
                        <input type="radio" 
                            name="status-${reg.id}" 
                            class="checkbox" 
                            value="Compliant" 
                            ${reg.status === 'Compliant' ? 'checked' : ''} 
                            onchange="updateStatus('${reg.id}', 'Compliant')"> Compliant
                    </label>
                    <label>
                        <input type="radio" 
                            name="status-${reg.id}" 
                            class="checkbox" 
                            value="Non Applicable" 
                            ${reg.status === 'Non Applicable' ? 'checked' : ''} 
                            onchange="updateStatus('${reg.id}', 'Non Applicable')"> Non Applicable
                    </label>
                    <label>
                        <input type="radio" 
                            name="status-${reg.id}" 
                            class="checkbox" 
                            value="Documentation" 
                            ${reg.status === 'Documentation' ? 'checked' : ''} 
                            onchange="updateStatus('${reg.id}', 'Documentation')"> Documentation
                    </label>
                    <label>
                        <input type="radio" 
                            name="status-${reg.id}" 
                            class="checkbox" 
                            value="Tous" 
                            ${reg.status === 'all' ? 'checked' : ''} 
                            onchange="updateStatus('${reg.id}', 'Tous')"> Remettre dans Tous
                    </label>
                </div>
                <div class="regulation-content">
                    <div class="regulation-text">${reg.text}</div>
                    <div class="regulation-id"><i>${reg.id}</i></div>
                    ${renderLinks(reg)}
                    
                    <div class="section-container ${reg.raciCollapsed ? 'collapsed' : ''}" data-section="raci">
                        <div class="section-header" onclick="toggleSection('${reg.id}', 'raci')">
                            <h4>
                                <span class="toggle-icon">${reg.raciCollapsed ? '▸' : '▾'}</span>
                                RACI
                            </h4>
                        </div>
                        <div class="section-content">
                            ${renderRACI(reg)}
                        </div>
                    </div>

                    <div class="section-container ${reg.actionsCollapsed ? 'collapsed' : ''}" data-section="actions">
                        <div class="section-header" onclick="toggleSection('${reg.id}', 'actions')">
                            <h4>
                                <span class="toggle-icon">${reg.actionsCollapsed ? '▸' : '▾'}</span>
                                Actions associées
                            </h4>
                        </div>
                        <div class="section-content">
                            <div>${renderActions(reg)}</div>
                            <div class="action-input-container">
                                <input type="text" class="input" id="action-input-${reg.id}" placeholder="Nouvelle action...">
                                <button class="button" onclick="addAction('${reg.id}', document.getElementById('action-input-${reg.id}').value)">
                                    Ajouter
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        `;
    });

    // Ajouter le bouton "Charger plus" si nécessaire
    if (endIndex < regulations.length) {
        const loadMoreButton = document.createElement('button');
        loadMoreButton.className = 'button load-more';
        loadMoreButton.textContent = 'Charger plus';
        loadMoreButton.onclick = () => {
            currentPage++;
            renderRegulations(false);
        };
        regulationsList.appendChild(loadMoreButton);
    }
}


// Mise à jour des gestionnaires d'événements pour réinitialiser le lazy loading
function handleSearchInput(event) {
    renderRegulations(true); // true pour reset
}

function handleCategoryFilter(event) {
    if (event.target.classList.contains('category-filter')) {
        document.querySelectorAll('.category-filter').forEach(filter => filter.classList.remove('active'));
        event.target.classList.add('active');
        activeFilter = event.target.dataset.category;
        renderRegulations(true); // true pour reset
    }
}

function handleStatusTabClick(event) {
    if (event.target.classList.contains('tab')) {
        document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
        event.target.classList.add('active');
        activeStatus = event.target.dataset.status;
        renderRegulations(true); // true pour reset
    }
}

// Ajouter les styles nécessaires
const lazyLoadStyles = `
    .loading-sentinel {
        height: 20px;
        margin: 20px 0;
    }

    .loading-indicator {
        text-align: center;
        padding: 20px;
        color: var(--gray-600);
    }

    /* Animation de chargement */
    @keyframes fadeIn {
        from { opacity: 0; }
        to { opacity: 1; }
    }

    .regulation-item {
        animation: fadeIn 0.3s ease-in;
    }
`;

// Ajouter les styles au document
function addLazyLoadStyles() {
    const styleElement = document.createElement('style');
    styleElement.textContent = lazyLoadStyles;
    document.head.appendChild(styleElement);
}




function renderRegulations() {
    const regulationsList = document.getElementById('wallItems');
    const complianceRate = document.querySelector('.compliance-rate');
    regulationsList.innerHTML = '';

    // Filtrer les réglementations en fonction des critères actuels
    let filteredRegs = regulations.filter(filterRegulation);

    // Calculer le taux de conformité basé sur les réglementations filtrées
    let compliancePercentage = calculateCompliance(filteredRegs);
    complianceRate.textContent = `Taux de conformité: ${compliancePercentage}%`;

    if (filteredRegs.length === 0) {
        regulationsList.innerHTML = '<div>Aucune exigence trouvée</div>';
    } else {
        filteredRegs.forEach(reg => {
            regulationsList.innerHTML += `
                <div class="regulation-item" id="regulation-${reg.id}">
                    <div class="regulation-header">
                        <!-- Radios de statut existants -->
                        <label>
                            <input type="radio" 
                                name="status-${reg.id}" 
                                class="checkbox" 
                                value="Compliant" 
                                ${reg.status === 'Compliant' ? 'checked' : ''} 
                                onchange="updateStatus('${reg.id}', 'Compliant')"> Compliant
                        </label>
                        <label>
                            <input type="radio" 
                                name="status-${reg.id}" 
                                class="checkbox" 
                                value="Non Applicable" 
                                ${reg.status === 'Non Applicable' ? 'checked' : ''} 
                                onchange="updateStatus('${reg.id}', 'Non Applicable')"> Non Applicable
                        </label>
                        <label>
                            <input type="radio" 
                                name="status-${reg.id}" 
                                class="checkbox" 
                                value="Documentation" 
                                ${reg.status === 'Documentation' ? 'checked' : ''} 
                                onchange="updateStatus('${reg.id}', 'Documentation')"> Documentation
                        </label>
                        <label>
                            <input type="radio" 
                                name="status-${reg.id}" 
                                class="checkbox" 
                                value="Tous" 
                                ${reg.status === 'all' ? 'checked' : ''} 
                                onchange="updateStatus('${reg.id}', 'Tous')"> Remettre dans Tous
                        </label>
                    </div>
                    <div class="regulation-content">
                        <div class="regulation-text">${reg.text}</div>
                        <div class="regulation-id"><i>${reg.id}</i></div>
                        ${renderLinks(reg)}
                        
                        <!-- Sections RACI et Actions avec toggle -->
                        <div class="section-container ${reg.raciCollapsed ? 'collapsed' : ''}" data-section="raci">
                            <div class="section-header" onclick="toggleSection('${reg.id}', 'raci')">
                                <h4>
                                    <span class="toggle-icon">${reg.raciCollapsed ? '▸' : '▾'}</span>
                                    RACI
                                </h4>
                            </div>
                            <div class="section-content">
                                ${renderRACI(reg)}
                            </div>
                        </div>

                        <div class="section-container ${reg.actionsCollapsed ? 'collapsed' : ''}" data-section="actions">
                            <div class="section-header" onclick="toggleSection('${reg.id}', 'actions')">
                                <h4>
                                    <span class="toggle-icon">${reg.actionsCollapsed ? '▸' : '▾'}</span>
                                    Actions associées
                                </h4>
                            </div>
                            <div class="section-content">
                                <div>${renderActions(reg)}</div>
                                <div class="action-input-container">
                                    <input type="text" class="input" id="action-input-${reg.id}" placeholder="Nouvelle action...">
                                    <button class="button" onclick="addAction('${reg.id}', document.getElementById('action-input-${reg.id}').value)">
                                        Ajouter
                                    </button>
                                </div>
                            </div>
                        </div>

                        ${renderJustification(reg)}
                        ${renderProofLinks(reg)}

                        <div class="action-buttons">
                            <button class="button secondary" onclick="editRegulation('${reg.id}')">Éditer</button>
                            <button class="button secondary" onclick="deleteRegulation('${reg.id}')">Supprimer</button>
                        </div>
                    </div>
                </div>
            `;
        });
    }
}




// Ajouter la fonction toggleSection
function toggleSection(regulationId, sectionType) {
    regulations = regulations.map(reg => {
        if (reg.id === regulationId) {
            const collapseKey = `${sectionType}Collapsed`;
            return {
                ...reg,
                [collapseKey]: !reg[collapseKey]
            };
        }
        return reg;
    });

    // Mettre à jour visuellement sans re-render complet
    const sectionContainer = document.querySelector(`#regulation-${regulationId} .section-container[data-section="${sectionType}"]`);
    if (sectionContainer) {
        sectionContainer.classList.toggle('collapsed');
        const toggleIcon = sectionContainer.querySelector('.toggle-icon');
        if (toggleIcon) {
            toggleIcon.textContent = sectionContainer.classList.contains('collapsed') ? '▸' : '▾';
        }
    }

    autoSave();
}



function updateStatus(regulationId, status) {
    regulations = regulations.map(reg => {
        if (reg.id === regulationId) {
            if (status === 'Tous') {
                return { ...reg, status: 'all', justification: '', proofLinks: [], justifications: [] };
            }
            return { ...reg, status: status, justification: status !== 'Non Applicable' ? '' : reg.justification, proofLinks: status !== 'Compliant' ? [] : reg.proofLinks };
        }
        return reg;
    });
    renderRegulations();
    autoSave();
}

function addJustification(regulationId) {
    const input = document.getElementById(`justification-input-${regulationId}`);
    const text = input.value.trim();
    if (!text) return;
    const timestamp = Date.now();
    regulations = regulations.map(reg => {
        if (reg.id === regulationId) {
            return {
                ...reg,
                justifications: [...(reg.justifications || []), { text, timestamp }]
            };
        }
        return reg;
    });
    input.value = '';
    renderRegulations();
    autoSave();
}

function deleteJustification(regulationId, index) {
    regulations = regulations.map(reg => {
        if (reg.id === regulationId) {
            const newJustifications = [...reg.justifications];
            newJustifications.splice(index, 1);
            return { ...reg, justifications: newJustifications };
        }
        return reg;
    });
    renderRegulations();
    autoSave();
}

function deleteProofLink(regulationId, index) {
    regulations = regulations.map(reg => {
        if (reg.id === regulationId) {
            const newProofLinks = [...reg.proofLinks];
            newProofLinks.splice(index, 1);
            return { ...reg, proofLinks: newProofLinks };
        }
        return reg;
    });
    renderRegulations();
    autoSave();
}

function addProof(regulationId, proofLink) {
    if (!proofLink.trim()) return;
    regulations = regulations.map(reg => {
        if (reg.id === regulationId) {
            return { ...reg, proofLinks: [...(reg.proofLinks || []), proofLink.trim()] };
        }
        return reg;
    });
    renderRegulations();
    autoSave();
    document.getElementById(`proof-input-${regulationId}`).value = '';
}

function editRegulation(regulationId) {
    regulations = regulations.map(reg => {
        if (reg.id === regulationId) {
            return { ...reg, isEditing: true };
        }
        return reg;
    });
    renderRegulations();
}

function saveRegulationEdit(regulationId) {
    const newText = document.getElementById(`edit-reg-text-${regulationId}`).value;
    regulations = regulations.map(reg => {
        if (reg.id === regulationId) {
            return { ...reg, text: newText, isEditing: false };
        }
        return reg;
    });
    renderRegulations();
    autoSave();
}

function cancelRegulationEdit(regulationId) {
    regulations = regulations.map(reg => {
        if (reg.id === regulationId) {
            return { ...reg, isEditing: false };
        }
        return reg;
    });
    renderRegulations();
}

function deleteRegulation(regulationId) {
    if (!confirm('Êtes-vous sûr de vouloir supprimer cette exigence ?')) return;
    regulations = regulations.filter(reg => reg.id !== regulationId);
    renderRegulations();
    autoSave();
}

function addAction(regulationId, actionText) {
    if (!actionText.trim()) return;

    const newAction = {
        id: Date.now(),
        text: actionText.trim(),
        percentage: 0,
        isEditing: false,
        isCollapsed: false, // Ajouter cette ligne
        risks: [],
        assignedTo: '',
        responsible: '',
        // RACI fields
        raci: {
            responsible: '',
            accountable: '',
            consulted: '',
            informed: ''
        },
        startDate: '',
        endDate: '',
        newDeadline: ''
    };

    regulations = regulations.map(reg => {
        if (reg.id === regulationId) {
            const updatedReg = {
                ...reg,
                actions: [...reg.actions, newAction]
            };
            return updatedReg;
        }
        return reg;
    });

    const actionsContainer = document.querySelector(`#regulation-${regulationId} .actions-container div`);
    if (actionsContainer) {
        const actionHtml = `
            <div class="action-item" id="action-${newAction.id}">
                <div class="action-content">
                    <span class="action-text">${newAction.text}</span>
                    <div class="action-buttons">
                        <button class="button secondary" onclick="editAction('${regulationId}', ${newAction.id})">Éditer</button>
                        <button class="button secondary" onclick="removeAction('${regulationId}', ${newAction.id})">Supprimer</button>
                        <button class="button secondary" onclick="addRiskPrompt('${regulationId}', ${newAction.id})">Ajouter un Risque</button>
                    </div>
                </div>
                <div class="risks-container"></div>
            </div>
        `;
        actionsContainer.insertAdjacentHTML('beforeend', actionHtml);
    }

    document.getElementById(`action-input-${regulationId}`).value = '';
    autoSave();
}
function addAction(regulationId, actionText) {
    if (!actionText.trim()) return;

    const newAction = {
        id: Date.now(),
        text: actionText.trim(),
        percentage: 0, // Initialize percentage
        isEditing: false,
        isCollapsed: false,
        risks: [],
        assignedTo: '',
        responsible: '',
        startDate: '',
        endDate: '',
        newDeadline: '',
        // RACI fields
        raci: {
            responsible: '',
            accountable: '',
            consulted: '',
            informed: ''
        }
    };

    regulations = regulations.map(reg => {
        if (reg.id === regulationId) {
            return {
                ...reg,
                actions: [...reg.actions, newAction]
            };
        }
        return reg;
    });

    renderRegulations();
    autoSave();
}
function addAction(regulationId, actionText) {
    if (!actionText.trim()) return;

    const newAction = {
        id: Date.now(),
        text: actionText.trim(),
        percentage: 0, // Initialisation du pourcentage
        isEditing: false,
        isCollapsed: false,
        risks: [],
        assignedTo: '',
        responsible: '',
        startDate: '',
        endDate: '',
        newDeadline: '',
        // Champs RACI initialisés
        raci: {
            responsible: '',
            accountable: '',
            consulted: '',
            informed: ''
        }
    };

    regulations = regulations.map(reg => {
        if (reg.id === regulationId) {
            return {
                ...reg,
                actions: [...reg.actions, newAction]
            };
        }
        return reg;
    });

    renderRegulations();
    autoSave();
}



function editAction(regulationId, actionId) {
    regulations = regulations.map(reg => {
        if (reg.id === regulationId) {
            return {
                ...reg,
                actions: reg.actions.map(action =>
                    action.id === actionId ? { ...action, isEditing: true } : action
                )
            };
        }
        return reg;
    });
    renderRegulations();
}

function saveActionEdit(regulationId, actionId) {
    const editTextElement = document.getElementById(`edit-text-${actionId}`);
    if (!editTextElement) {
        console.error(`L'élément d'édition avec l'ID edit-text-${actionId} est introuvable.`);
        return;
    }

    const newText = editTextElement.value.trim();
    const newPercentage = parseInt(document.getElementById(`edit-percentage-${actionId}`)?.value) || 0;

    regulations = regulations.map(reg => {
        if (reg.id === regulationId) {
            return {
                ...reg,
                actions: reg.actions.map(action =>
                    action.id === actionId
                        ? { ...action, text: newText, percentage: newPercentage, isEditing: false }
                        : action
                )
            };
        }
        return reg;
    });
    renderRegulations();
    autoSave();
}

function cancelActionEdit(regulationId, actionId) {
    regulations = regulations.map(reg => {
        if (reg.id === regulationId) {
            return {
                ...reg,
                actions: reg.actions.map(action =>
                    action.id === actionId
                        ? { ...action, isEditing: false }
                        : action
                )
            };
        }
        return reg;
    });
    renderRegulations();
}

// Modifier le gestionnaire de suppression d'action
function removeAction(regulationId, actionId) {
    const actionElement = document.getElementById(`action-${actionId}`);
    if (!actionElement) return;

    // Créer la boîte de dialogue de confirmation
    const confirmDialog = document.createElement('div');
    confirmDialog.className = 'confirm-dialog';
    confirmDialog.innerHTML = `
        <div class="confirm-dialog-content">
            <h3>Confirmation de suppression</h3>
            <p>Êtes-vous sûr de vouloir supprimer cette action ?</p>
            <p class="warning-text">Cette action est irréversible.</p>
            <div class="confirm-buttons">
                <button class="button secondary" onclick="cancelDeleteAction('${actionId}')">Annuler</button>
                <button class="button danger" onclick="confirmDeleteAction('${regulationId}', '${actionId}')">Supprimer</button>
            </div>
        </div>
    `;

    // Ajouter la boîte de dialogue au corps du document
    document.body.appendChild(confirmDialog);

    // Ajouter un effet de fade-in
    setTimeout(() => confirmDialog.classList.add('visible'), 10);
}

function cancelDeleteAction(actionId) {
    const confirmDialog = document.querySelector('.confirm-dialog');
    if (confirmDialog) {
        confirmDialog.classList.remove('visible');
        setTimeout(() => confirmDialog.remove(), 300);
    }
}

function confirmDeleteAction(regulationId, actionId) {
    const actionElement = document.getElementById(`action-${actionId}`);
    if (actionElement) {
        actionElement.classList.add('removing');
        setTimeout(() => {
            actionElement.remove();

            regulations = regulations.map(reg => {
                if (reg.id === regulationId) {
                    return {
                        ...reg,
                        actions: reg.actions.filter(action => action.id !== actionId)
                    };
                }
                return reg;
            });

            autoSave();
        }, 300);
    }

    // Fermer la boîte de dialogue
    cancelDeleteAction(actionId);
}

function addRiskPrompt(regulationId, actionId) {
    const description = prompt("Entrez la description du risque :");
    const severity = prompt("Entrez le niveau de gravité (1-5) :");
    const likelihood = prompt("Entrez le niveau de vraisemblance (1-5) :");

    if (description && severity && likelihood) {
        addRisk(regulationId, actionId, description, parseInt(severity), parseInt(likelihood));
    }
}

function addRisk(regulationId, actionId, description, severity, likelihood) {
    actionId = Number(actionId);
    
    const risk = {
        id: Date.now(),
        description: description,
        severity: severity,
        likelihood: likelihood,
        level: severity * likelihood,
        remediationActions: [],
        remediated: false
    };

    regulations = regulations.map(reg => {
        if (reg.id === regulationId) {
            return {
                ...reg,
                actions: reg.actions.map(action => {
                    if (action.id === actionId) {
                        if (!Array.isArray(action.risks)) {
                            action.risks = [];
                        }
                        return { ...action, risks: [...action.risks, risk] };
                    }
                    return action;
                })
            };
        }
        return reg;
    });

    const risksContainer = document.querySelector(`#action-${actionId} .risks-container`);
    if (risksContainer) {
        const riskHtml = `
            <div class="risk-item" id="risk-${risk.id}">
                <p><strong>Risque:</strong> ${risk.description}</p>
                <p>
                    <strong>Gravité:</strong> ${risk.severity} 
                    <strong>Vraisemblance:</strong> ${risk.likelihood} 
                    <strong>Niveau:</strong> ${risk.level}
                </p>
                <div class="button-group">
                    <button class="button secondary" onclick="addRemediationPrompt('${regulationId}', ${actionId}, ${risk.id})">
                        Ajouter une Remédiation
                    </button>
                    <button class="button secondary" onclick="confirmDeleteRisk('${regulationId}', ${actionId}, ${risk.id})">
                        Supprimer
                    </button>
                </div>
            </div>
        `;
        risksContainer.insertAdjacentHTML('beforeend', riskHtml);
    }

    autoSave();
}

function addRemediation(regulationId, actionId, riskId, remediationText) {
    actionId = Number(actionId);
    riskId = Number(riskId);

    // Trouve d'abord le risque pour accéder à ses données
    let currentRisk;
    regulations = regulations.map(reg => {
        if (reg.id === regulationId) {
            return {
                ...reg,
                actions: reg.actions.map(action => {
                    if (action.id === actionId) {
                        return {
                            ...action,
                            risks: action.risks.map(risk => {
                                if (risk.id === riskId) {
                                    // Stocke la référence au risque pour l'utiliser plus tard
                                    currentRisk = risk;
                                    return {
                                        ...risk,
                                        remediationActions: [...(risk.remediationActions || []), remediationText]
                                    };
                                }
                                return risk;
                            })
                        };
                    }
                    return action;
                })
            };
        }
        return reg;
    });

    const riskElement = document.getElementById(`risk-${riskId}`);
    if (riskElement) {
        const remediationsContainer = riskElement.querySelector('.remediation-actions') || document.createElement('div');
        remediationsContainer.classList.add('remediation-actions');
        
        // Utilise currentRisk pour accéder au nombre actuel de remédiations
        const remediationIndex = currentRisk ? (currentRisk.remediationActions?.length || 0) : 0;
        
        const remediationHtml = `
            <div class="remediation-item" data-index="${remediationIndex - 1}">
                <span class="remediation-text">${remediationText}</span>
                <div class="remediation-buttons">
                    <button class="button secondary" onclick="editRemediationPrompt('${regulationId}', ${actionId}, ${riskId}, ${remediationIndex - 1})">
                        Éditer
                    </button>
                    <button class="button secondary" onclick="confirmDeleteRemediation('${regulationId}', ${actionId}, ${riskId}, ${remediationIndex - 1})">
                        Supprimer
                    </button>
                </div>
            </div>
        `;
        remediationsContainer.insertAdjacentHTML('beforeend', remediationHtml);
        
        if (!riskElement.contains(remediationsContainer)) {
            riskElement.appendChild(remediationsContainer);
        }
    }

    autoSave();
}

function addRemediationPrompt(regulationId, actionId, riskId) {
    const remediationText = prompt("Entrez l'action de remédiation :");

    if (remediationText) {
        addRemediation(regulationId, actionId, riskId, remediationText);
    }
}

function removeRisk(regulationId, actionId, riskId) {
    actionId = Number(actionId);
    riskId = Number(riskId);

    const riskElement = document.getElementById(`risk-${riskId}`);
    if (riskElement) {
        riskElement.classList.add('removing');
        setTimeout(() => {
            riskElement.remove();

            regulations = regulations.map(reg => {
                if (reg.id === regulationId) {
                    return {
                        ...reg,
                        actions: reg.actions.map(action => {
                            if (action.id === actionId) {
                                return {
                                    ...action,
                                    risks: action.risks.filter(risk => risk.id !== riskId)
                                };
                            }
                            return action;
                        })
                    };
                }
                return reg;
            });

            autoSave();
        }, 300);
    }
}

function editRisk(regulationId, actionId, riskId) {
    regulations = regulations.map(reg => {
        if (reg.id === regulationId) {
            return {
                ...reg,
                actions: reg.actions.map(action => {
                    if (action.id === actionId) {
                        return {
                            ...action,
                            risks: action.risks.map(risk =>
                                risk.id === riskId
                                    ? { ...risk, isEditing: true }
                                    : risk
                            )
                        };
                    }
                    return action;
                })
            };
        }
        return reg;
    });
    renderRegulations();
}

function saveRiskEdit(regulationId, actionId, riskId) {
    const severity = parseInt(document.getElementById(`edit-severity-${riskId}`).value);
    const likelihood = parseInt(document.getElementById(`edit-likelihood-${riskId}`).value);
    const description = document.getElementById(`edit-description-${riskId}`).value.trim();
    if (isNaN(severity) || isNaN(likelihood) || severity < 1 || severity >5 || likelihood < 1 || likelihood > 5 || !description) {
        alert("Entrées invalides. Veuillez vérifier vos entrées.");
        return;
    }
    const riskLevel = severity * likelihood;
    regulations = regulations.map(reg => {
        if (reg.id === regulationId) {
            return {
                ...reg,
                actions: reg.actions.map(action => {
                    if (action.id === actionId) {
                        return {
                            ...action,
                            risks: action.risks.map(risk =>
                                risk.id === riskId
                                    ? { ...risk, severity, likelihood, level: riskLevel, description, isEditing: false }
                                    : risk
                            )
                        };
                    }
                    return action;
                })
            };
        }
        return reg;
    });
    renderRegulations();
    autoSave();
}

function cancelRiskEdit(regulationId, actionId, riskId) {
    regulations = regulations.map(reg => {
        if (reg.id === regulationId) {
            return {
                ...reg,
                actions: reg.actions.map(action => {
                    if (action.id === actionId) {
                        return {
                            ...action,
                            risks: action.risks.map(risk =>
                                risk.id === riskId
                                    ? { ...risk, isEditing: false }
                                    : risk
                            )
                        };
                    }
                    return action;
                })
            };
        }
        return reg;
    });
    renderRegulations();
}

function deleteRisk(regulationId, actionId, riskId) {
    if (!confirm('Êtes-vous sûr de vouloir supprimer ce risque ?')) return;
    regulations = regulations.map(reg => {
        if (reg.id === regulationId) {
            return {
                ...reg,
                actions: reg.actions.map(action => {
                    if (action.id === actionId) {
                        return {
                            ...action,
                            risks: action.risks.filter(risk => risk.id !== riskId)
                        };
                    }
                    return action;
                })
            };
        }
        return reg;
    });
    renderRegulations();
    autoSave();
}

function autoSave() {
    localStorage.setItem('doraCompliance', JSON.stringify(regulations));
    const saveStatus = document.getElementById('saveStatus');
    saveStatus.classList.add('visible');
    setTimeout(() => {
        saveStatus.classList.remove('visible');
    }, 2000);
}

function autoLoad() {
    const savedState = localStorage.getItem('doraCompliance');
    if (savedState) {
        regulations = JSON.parse(savedState);
        // Initialiser les champs de catégorie pour chaque régulation si non définis
        regulations.forEach(reg => {
            reg.isCompliant = reg.isCompliant || false;
            reg.isApplicable = reg.isApplicable !== undefined ? reg.isApplicable : true; // Par défaut, applicable
            reg.isDocumentation = reg.isDocumentation || false;
            
            // Initialiser raci pour chaque action si non défini
            if (Array.isArray(reg.actions)) {
                reg.actions.forEach(action => {
                    if (!action.raci) {
                        action.raci = {
                            responsible: '',
                            accountable: '',
                            consulted: '',
                            informed: ''
                        };
                    }
                });
            }
        });
    } else {
        regulations = initializeRegulations();
    }
}




function exportData() {
    const dataStr = JSON.stringify(regulations, null, 2);
    const dataUri = 'data:application/json;charset=utf-8,' + encodeURIComponent(dataStr);
    const exportFileDefaultName = 'dora-compliance.json';
    const linkElement = document.createElement('a');
    linkElement.setAttribute('href', dataUri);
    linkElement.setAttribute('download', exportFileDefaultName);
    document.body.appendChild(linkElement); // Required for Firefox
    linkElement.click();
    linkElement.remove();
}

function exportProject() {
    const wb = XLSX.utils.book_new();
    const wsData = [];

    wsData.push(['Category', 'Reference', 'Action', 'Assigné à', 'Responsable', 'Date de début', 'Date de fin', 'Nouvelle Deadline', 'Progression', 'Existence de risque', 'Existence de remédiation']);

    regulations.forEach(reg => {
        reg.actions.forEach(action => {
            const hasUnremediatedRisk = action.risks && action.risks.some(risk => !risk.remediated);
            const hasRemediation = action.risks && action.risks.some(risk => risk.remediationActions && risk.remediationActions.length > 0);

            wsData.push([
                reg.category,
                reg.id,
                action.text,
                action.assignedTo || '',
                action.responsible || '',
                action.startDate || '',
                action.endDate || '',
                action.newDeadline || '',
                action.percentage || 0,
                hasUnremediatedRisk ? 'x' : '',
                hasRemediation ? 'x' : ''
            ]);
        });
    });

    const ws = XLSX.utils.aoa_to_sheet(wsData);
    XLSX.utils.book_append_sheet(wb, ws, 'Projet');
    XLSX.writeFile(wb, 'projet.xlsx');
}
function exportProject() {
    const wb = XLSX.utils.book_new();
    const wsData = [];

    // Mettre à jour les en-têtes pour inclure RACI
    wsData.push([
        'Category', 
        'Reference', 
        'Responsible (R)', // RACI de l'exigence
        'Accountable (A)',
        'Consulted (C)',
        'Informed (I)',
        'Action', 
        'Assigné à', 
        'Responsable', 
        'Date de début', 
        'Date de fin', 
        'Nouvelle Deadline', 
        'Progression', 
        'Existence de risque', 
        'Existence de remédiation'
    ]);

    regulations.forEach(reg => {
        // Si pas d'actions, exporter quand même l'exigence avec ses informations RACI
        if (!reg.actions || reg.actions.length === 0) {
            wsData.push([
                reg.category,
                reg.id,
                reg.responsible || '',
                reg.accountable || '',
                reg.consulted || '',
                reg.informed || '',
                '', // Action vide
                '', // Assigné à
                '', // Responsable
                '', // Date début
                '', // Date fin
                '', // Deadline
                '', // Progression
                '', // Risque
                ''  // Remédiation
            ]);
        } else {
            reg.actions.forEach(action => {
                const hasUnremediatedRisk = action.risks && action.risks.some(risk => !risk.remediated);
                const hasRemediation = action.risks && action.risks.some(risk => risk.remediationActions && risk.remediationActions.length > 0);

                wsData.push([
                    reg.category,
                    reg.id,
                    reg.responsible || '',  // RACI de l'exigence
                    reg.accountable || '',
                    reg.consulted || '',
                    reg.informed || '',
                    action.text,
                    action.assignedTo || '',
                    action.responsible || '',
                    action.startDate || '',
                    action.endDate || '',
                    action.newDeadline || '',
                    action.percentage || 0,
                    hasUnremediatedRisk ? 'x' : '',
                    hasRemediation ? 'x' : ''
                ]);
            });
        }
    });

    // Style pour le header
    const ws = XLSX.utils.aoa_to_sheet(wsData);
    
    // Définir la largeur des colonnes
    const colWidths = [
        {wch: 10},  // Category
        {wch: 12},  // Reference
        {wch: 30},  // Responsible (R)
        {wch: 30},  // Accountable (A)
        {wch: 30},  // Consulted (C)
        {wch: 30},  // Informed (I)
        {wch: 50},  // Action
        {wch: 15},  // Assigné à
        {wch: 15},  // Responsable
        {wch: 12},  // Date début
        {wch: 12},  // Date fin
        {wch: 12},  // Nouvelle Deadline
        {wch: 10},  // Progression
        {wch: 10},  // Existence risque
        {wch: 10}   // Existence remédiation
    ];

    ws['!cols'] = colWidths;

    // Style pour le header (première ligne)
    for (let i = 0; i < 15; i++) {
        const cellRef = XLSX.utils.encode_cell({r: 0, c: i});
        if (!ws[cellRef]) ws[cellRef] = {};
        ws[cellRef].s = {
            font: { bold: true },
            fill: { fgColor: { rgb: "CCCCCC" } },
            alignment: { vertical: 'center', horizontal: 'center' }
        };
    }

    XLSX.utils.book_append_sheet(wb, ws, 'Projet');
    XLSX.writeFile(wb, 'projet.xlsx');
}
function exportProject() {
    const wb = XLSX.utils.book_new();
    const wsData = [];

    // Updated headers to include RACI and Percentage
    wsData.push([
        'Category', 
        'Reference', 
        'Responsible (R)', 
        'Accountable (A)',
        'Consulted (C)',
        'Informed (I)',
        'Action', 
        'Assigné à', 
        'Responsable', 
        'Date de début', 
        'Date de fin', 
        'Nouvelle Deadline', 
        'Progression (%)', // Added Percentage
        'Existence de risque', 
        'Existence de remédiation'
    ]);

    regulations.forEach(reg => {
        if (!reg.actions || reg.actions.length === 0) {
            wsData.push([
                reg.category,
                reg.id,
                reg.responsible || '',
                reg.accountable || '',
                reg.consulted || '',
                reg.informed || '',
                '', // Action
                '', // Assigné à
                '', // Responsable
                '', // Date début
                '', // Date fin
                '', // Deadline
                '', // Progression
                '', // Risque
                ''  // Remédiation
            ]);
        } else {
            reg.actions.forEach(action => {
                const hasUnremediatedRisk = action.risks && action.risks.some(risk => !risk.remediated);
                const hasRemediation = action.risks && action.risks.some(risk => risk.remediationActions && risk.remediationActions.length > 0);

                wsData.push([
                    reg.category,
                    reg.id,
                    reg.responsible || '',  // RACI de l'exigence
                    reg.accountable || '',
                    reg.consulted || '',
                    reg.informed || '',
                    action.text,
                    action.assignedTo || '',
                    action.responsible || '',
                    action.startDate || '',
                    action.endDate || '',
                    action.newDeadline || '',
                    action.percentage || 0, // Percentage
                    hasUnremediatedRisk ? 'x' : '',
                    hasRemediation ? 'x' : ''
                ]);
            });
        }
    });

    const ws = XLSX.utils.aoa_to_sheet(wsData);

    // Define column widths
    const colWidths = [
        {wch: 10},  // Category
        {wch: 12},  // Reference
        {wch: 20},  // Responsible (R)
        {wch: 20},  // Accountable (A)
        {wch: 20},  // Consulted (C)
        {wch: 20},  // Informed (I)
        {wch: 30},  // Action
        {wch: 15},  // Assigné à
        {wch: 15},  // Responsable
        {wch: 12},  // Date début
        {wch: 12},  // Date fin
        {wch: 15},  // Nouvelle Deadline
        {wch: 15},  // Progression (%)
        {wch: 10},  // Existence risque
        {wch: 10}   // Existence remédiation
    ];

    ws['!cols'] = colWidths;

    // Style for the header row
    for (let i = 0; i < wsData[0].length; i++) {
        const cellRef = XLSX.utils.encode_cell({r: 0, c: i});
        if (!ws[cellRef]) ws[cellRef] = {};
        ws[cellRef].s = {
            font: { bold: true },
            fill: { fgColor: { rgb: "CCCCCC" } },
            alignment: { vertical: 'center', horizontal: 'center' }
        };
    }

    XLSX.utils.book_append_sheet(wb, ws, 'Projet');
    XLSX.writeFile(wb, 'projet.xlsx');
}


function markRiskAsRemediated(regulationId, actionId, riskId) {
    regulations = regulations.map(reg => {
        if (reg.id === regulationId) {
            return {
                ...reg,
                actions: reg.actions.map(action => {
                    if (action.id === actionId) {
                        return {
                            ...action,
                            risks: action.risks.map(risk => {
                                if (risk.id === riskId) {
                                    return {
                                        ...risk,
                                        remediated: true
                                    };
                                }
                                return risk;
                            })
                        };
                    }
                    return action;
                })
            };
        }
        return reg;
    });
    renderRegulations();
    autoSave();
}

function renderRisks(regulationId, actionId) {
    if (!regulationId || actionId === undefined) {
        console.error('IDs manquants ou invalides:', { regulationId, actionId });
        return '';
    }

    actionId = Number(actionId);

    const regulation = regulations.find(reg => reg.id === regulationId);
    if (!regulation) return '';

    const action = regulation.actions.find(act => act.id === actionId);
    if (!action || !Array.isArray(action.risks)) return '';

    return action.risks.map(risk => `
        <div class="risk-item" id="risk-${risk.id}">
            <div class="risk-content">
                <p><strong>Risque:</strong> ${risk.description}</p>
                <p>
                    <strong>Gravité:</strong> ${risk.severity} 
                    <strong>Vraisemblance:</strong> ${risk.likelihood} 
                    <strong>Niveau:</strong> ${risk.level}
                </p>
                ${renderRemediations(risk, regulationId, actionId)}
                <div class="button-group">
                    <button class="button secondary" onclick="addRemediationPrompt('${regulationId}', ${actionId}, ${risk.id})">
                        Ajouter une Remédiation
                    </button>
                    <button class="button secondary" onclick="confirmDeleteRisk('${regulationId}', ${actionId}, ${risk.id})">
                        Supprimer
                    </button>
                    ${!risk.remediated ? `
                        <button class="button secondary" onclick="markRiskAsRemediated('${regulationId}', ${actionId}, ${risk.id})">
                            Marquer comme remédié
                        </button>
                    ` : ''}
                </div>
            </div>
        </div>
    `).join('');
}


function renderRemediations(risk, regulationId, actionId) {
    if (!risk || !Array.isArray(risk.remediationActions) || risk.remediationActions.length === 0) {
        return '';
    }

    return `
        <div class="remediation-actions">
            <strong>Actions de Remédiation:</strong>
            <ul class="remediation-list">
                ${risk.remediationActions.map((remediation, index) => `
                    <li class="remediation-item" data-index="${index}">
                        <span class="remediation-text">${remediation || ''}</span>
                        <div class="remediation-buttons">
                            <button class="button secondary" 
                                onclick="editRemediationPrompt('${regulationId}', ${actionId}, ${risk.id}, ${index})">
                                Éditer
                            </button>
                            <button class="button secondary" 
                                onclick="confirmDeleteRemediation('${regulationId}', ${actionId}, ${risk.id}, ${index})">
                                Supprimer
                            </button>
                        </div>
                    </li>
                `).join('')}
            </ul>
        </div>
    `;
}


function confirmDeleteRemediation(regulationId, actionId, riskId, remediationIndex) {
    if (confirm("Êtes-vous sûr de vouloir supprimer cette action de remédiation ?")) {
        removeRemediationAction(regulationId, actionId, riskId, remediationIndex);
    }
}

function removeRemediationAction(regulationId, actionId, riskId, remediationIndex) {
    actionId = Number(actionId);
    riskId = Number(riskId);
    remediationIndex = Number(remediationIndex);

    // Mettre à jour l'état avant l'animation
    regulations = regulations.map(reg => {
        if (reg.id === regulationId) {
            return {
                ...reg,
                actions: reg.actions.map(action => {
                    if (action.id === actionId) {
                        return {
                            ...action,
                            risks: action.risks.map(risk => {
                                if (risk.id === riskId && Array.isArray(risk.remediationActions)) {
                                    const updatedRemediations = [...risk.remediationActions];
                                    updatedRemediations.splice(remediationIndex, 1);
                                    return {
                                        ...risk,
                                        remediationActions: updatedRemediations
                                    };
                                }
                                return risk;
                            })
                        };
                    }
                    return action;
                })
            };
        }
        return reg;
    });

    // Sauvegarder immédiatement
    autoSave();

    // Mettre à jour l'affichage
    renderRegulations();
}


function editRemediationPrompt(regulationId, actionId, riskId, remediationIndex) {
    const regulation = regulations.find(reg => reg.id === regulationId);
    if (!regulation) return;

    const action = regulation.actions.find(act => act.id === Number(actionId));
    if (!action) return;

    const risk = action.risks.find(r => r.id === Number(riskId));
    if (!risk || !risk.remediationActions) return;

    const currentRemediationText = risk.remediationActions[remediationIndex];
    const newRemediationText = prompt("Modifiez l'intitulé de la remédiation :", currentRemediationText);

    if (newRemediationText !== null && newRemediationText.trim() !== "") {
        regulations = regulations.map(reg => {
            if (reg.id === regulationId) {
                return {
                    ...reg,
                    actions: reg.actions.map(action => {
                        if (action.id === Number(actionId)) {
                            return {
                                ...action,
                                risks: action.risks.map(risk => {
                                    if (risk.id === Number(riskId)) {
                                        const updatedRemediationActions = [...risk.remediationActions];
                                        updatedRemediationActions[remediationIndex] = newRemediationText.trim();
                                        return {
                                            ...risk,
                                            remediationActions: updatedRemediationActions
                                        };
                                    }
                                    return risk;
                                })
                            };
                        }
                        return action;
                    })
                };
            }
            return reg;
        });

        const remediationTextElement = document.querySelector(`#risk-${riskId} .remediation-item[data-index="${remediationIndex}"] .remediation-text`);
        if (remediationTextElement) {
            remediationTextElement.textContent = newRemediationText.trim();
        }

        autoSave();
    }
}

function confirmDeleteRisk(regulationId, actionId, riskId) {
    if (confirm("Êtes-vous sûr de vouloir supprimer ce risque ?")) {
        removeRisk(regulationId, actionId, riskId);
    }
}

function importData(event) {
    const file = event.target.files[0];
    const reader = new FileReader();
    reader.onload = function(e) {
        try {
            const importedData = JSON.parse(e.target.result);
            regulations = importedData;
            autoSave();
            renderRegulations();
        } catch (error) {
            alert('Erreur lors de l\'importation du fichier. Assurez-vous que le format est correct.');
        }
    };
    reader.readAsText(file);
    event.target.value = '';
}

function handleSearchInput(event) {
    renderRegulations();
}

function handleCategoryFilter(event) {
    if (event.target.classList.contains('category-filter')) {
        document.querySelectorAll('.category-filter').forEach(filter => filter.classList.remove('active'));
        event.target.classList.add('active');
        activeFilter = event.target.dataset.category;
        renderRegulations();
    }
}

function handleStatusTabClick(event) {
    if (event.target.classList.contains('tab')) {
        document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
        event.target.classList.add('active');
        activeStatus = event.target.dataset.status;
        renderRegulations();
    }
}

function resetArticleForm() {
    document.getElementById('articleCategory').value = '';
    document.getElementById('articleReference').value = '';
    document.getElementById('articleText').value = '';
    document.getElementById('rtsLink').value = '';
    document.getElementById('itsLink').value = '';
    document.getElementById('level1Link').value = '';
    document.getElementById('formError').textContent = '';
    toggleConditionalFields();
}

function resetAll() {
    const confirmReset = confirm('⚠️ ATTENTION : Vous êtes sur le point de réinitialiser TOUTE l\'application et supprimer TOUTES les données. Cette action est irréversible. Voulez-vous vraiment continuer ?');
    if (confirmReset) {
        regulations = initializeRegulations();
        autoSave();
        resetArticleForm();
        renderRegulations();
    }
}

// Fonction pour ajouter un nouvel article
async function addNewArticle() {
    const category = document.getElementById('articleCategory').value;
    const reference = document.getElementById('articleReference').value;
    const text = document.getElementById('articleText').value;
    
    if (!category || !reference || !text) {
        showError('Tous les champs sont obligatoires');
        return;
    }

    showLoading();
    
    try {
        const parsedRequirements = parseRequirementsFromText(text);
        const batch = db.batch();

        // Création des articles dans Firestore
        for (const req of parsedRequirements) {
            const articleId = `${reference}-${req.id}`;
            const docRef = db.collection('regulations').doc(articleId);
            
            const articleData = {
                id: articleId,
                category: category,
                text: req.originalText,
                fullPath: req.id,
                parentChain: req.parentChain,
                status: 'all',
                actions: [],
                justification: '',
                proofLinks: [],
                justifications: [],
                responsible: '',
                accountable: '',
                consulted: '',
                informed: '',
                raciCollapsed: false,
                actionsCollapsed: false,
                createdAt: firebase.firestore.FieldValue.serverTimestamp()
            };

            // Ajout des liens spécifiques selon la catégorie
            if (category === 'Level 1') {
                articleData.rtsLinks = document.getElementById('rtsLink').value
                    .split(',').map(s => s.trim()).filter(Boolean);
                articleData.itsLinks = document.getElementById('itsLink').value
                    .split(',').map(s => s.trim()).filter(Boolean);
            } else if (category === 'RTS' || category === 'ITS') {
                articleData.level1Link = document.getElementById('level1Link').value.trim();
            }

            batch.set(docRef, articleData);
        }

        await batch.commit();
        
        resetArticleForm();
        showNotification('Articles ajoutés avec succès', 'success');
        
        // Recharger les données
        await resetAndReload();
        
    } catch (error) {
        console.error('Erreur lors de l\'ajout:', error);
        showNotification('Erreur lors de l\'ajout des articles', 'error');
    } finally {
        hideLoading();
    }
}


// Fonctions de gestion du chargement progressif
let lastLoadedDoc = null;

async function loadMoreRegulations() {
    if (isLoading) return;
    
    isLoading = true;
    showLoading();

    try {
        let query = db.collection('regulations')
            .orderBy('createdAt', 'desc')
            .limit(BATCH_SIZE);

        if (lastLoadedDoc) {
            query = query.startAfter(lastLoadedDoc);
        }

        const snapshot = await query.get();
        const regulations = [];

        snapshot.forEach(doc => {
            regulations.push(doc.data());
        });

        if (regulations.length > 0) {
            lastLoadedDoc = snapshot.docs[snapshot.docs.length - 1];
            renderRegulationsBatch(regulations);
            
            // Configurer l'observation pour le prochain lot
            setupIntersectionObserver();
        }

        if (snapshot.empty) {
            hideLoadMoreButton();
        }

    } catch (error) {
        console.error('Erreur de chargement:', error);
        showNotification('Erreur lors du chargement des articles', 'error');
    } finally {
        isLoading = false;
        hideLoading();
    }
}
function loadMoreRegulations() {
    if (db) {
        db.collection('moreRegulations').get()
            .then((querySnapshot) => {
                querySnapshot.forEach((doc) => {
                    console.log(doc.id, " => ", doc.data());
                });
            })
            .catch((error) => {
                console.error("Erreur lors du chargement des réglementations supplémentaires:", error);
            });
    } else {
        console.error("Firestore is not initialized.");
    }
}
function renderRegulationsBatch(regulations) {
    const container = document.getElementById('wallItems');
    
    regulations.forEach(reg => {
        const regulationElement = document.createElement('div');
        regulationElement.className = 'regulation-item fade-in';
        regulationElement.id = `regulation-${reg.id}`;
        regulationElement.innerHTML = `
            <div class="regulation-header">
                <!-- Votre code HTML existant pour l'en-tête -->
            </div>
            <div class="regulation-content">
                <div class="regulation-text">${reg.text}</div>
                <div class="regulation-id"><i>${reg.id}</i></div>
                ${renderLinks(reg)}
                ${renderRACI(reg)}
                ${renderActions(reg)}
                ${renderJustification(reg)}
                ${renderProofLinks(reg)}
            </div>
        `;
        
        container.appendChild(regulationElement);
    });
}

function setupIntersectionObserver() {
    const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
            if (entry.isIntersecting && !isLoading) {
                loadMoreRegulations();
            }
        });
    }, {
        rootMargin: '100px',
        threshold: 0.1
    });

    // Créer ou mettre à jour la sentinelle
    let sentinel = document.querySelector('.load-sentinel');
    if (!sentinel) {
        sentinel = document.createElement('div');
        sentinel.className = 'load-sentinel';
        document.getElementById('wallItems').appendChild(sentinel);
    }

    observer.observe(sentinel);
}

// Fonction pour réinitialiser et recharger
function resetAndReload() {
    lastDoc = null;
    return loadRegulations(true);
}


// Fonctions utilitaires
function showLoading() {
    let loader = document.querySelector('.global-loader');
    if (!loader) {
        loader = document.createElement('div');
        loader.className = 'global-loader';
        loader.innerHTML = '<div class="loader-spinner"></div>';
        document.body.appendChild(loader);
    }
    loader.style.display = 'flex';
}

function hideLoading() {
    const loader = document.querySelector('.global-loader');
    if (loader) {
        loader.style.display = 'none';
    }
}

function parseRequirementsFromText(text) {
    // Nettoyer les lignes
    const lines = text.split(/\r?\n/)
        .map(line => line.replace(/\r$/, ''))
        .filter(line => line.trim())
        .map(line => ({
            text: line.trim(),
            indent: line.search(/\S/)
        }));

    const requirements = [];

    // Pour chaque ligne, regarder si c'est une feuille et trouver son vrai parent
    for (let i = 0; i < lines.length; i++) {
        const current = lines[i];
        const next = lines[i + 1];
        
        // Une ligne est une feuille si :
        // - Elle a un parent (une ligne au-dessus moins indentée)
        // - ET soit c'est la dernière ligne, soit la suivante n'est pas plus indentée
        let hasParent = false;
        let parentIndex = i - 1;
        while (parentIndex >= 0) {
            if (lines[parentIndex].indent < current.indent) {
                hasParent = true;
                break;
            }
            parentIndex--;
        }

        const isLastLine = i === lines.length - 1;
        const isLeaf = hasParent && (isLastLine || !next || next.indent <= current.indent);

        if (isLeaf) {
            // Trouver le vrai parent (première ligne au-dessus avec indentation moindre)
            let parentChain = [];
            let currentIndent = current.indent;
            let searchIndex = i - 1;
            
            while (searchIndex >= 0) {
                const potentialParent = lines[searchIndex];
                if (potentialParent.indent < currentIndent) {
                    parentChain.unshift(potentialParent.text);
                    currentIndent = potentialParent.indent;
                    if (currentIndent === 0) break; // On a atteint la racine
                }
                searchIndex--;
            }

            requirements.push({
                id: [...parentChain, current.text].join('.'),
                originalText: current.text,
                parentChain: parentChain
            });
        }
    }

    return requirements;
}

  // Fonction helper pour vérifier la validité du parsing
function validateRequirementsParsing(text) {
    const requirements = parseRequirementsFromText(text);
    console.log("Requirements parsed:", requirements);
    
    requirements.forEach((req, index) => {
        console.log(`\nRequirement #${index + 1}:`);
        console.log("ID:", req.id);
        console.log("Original Text:", req.originalText);
        console.log("Context:", req.context);
        console.log("Full Text:", req.fullText);
        console.log("Level:", req.level);
        console.log("Parent Chain:", req.parentChain);
    });
    
    return requirements;
}

function renderRACI(reg) {
    return `
        <div class="raci-container">
            <h4>RACI</h4>
            <div class="raci-grid">
                <div class="raci-row">
                    <div class="raci-label">Responsables (R):</div>
                    <div class="raci-input">
                        <input type="text" 
                            class="input" 
                            id="responsible-${reg.id}" 
                            value="${reg.responsible || ''}" 
                            placeholder="Noms des responsables (séparés par des virgules)"
                            onchange="updateRACI('${reg.id}', 'responsible', this.value)">
                    </div>
                </div>
                <div class="raci-row">
                    <div class="raci-label">Autorité (A):</div>
                    <div class="raci-input">
                        <input type="text" 
                            class="input" 
                            id="accountable-${reg.id}" 
                            value="${reg.accountable || ''}" 
                            placeholder="Nom de la personne ayant autorité"
                            onchange="updateRACI('${reg.id}', 'accountable', this.value)">
                    </div>
                </div>
                <div class="raci-row">
                    <div class="raci-label">Consultés (C):</div>
                    <div class="raci-input">
                        <input type="text" 
                            class="input" 
                            id="consulted-${reg.id}" 
                            value="${reg.consulted || ''}" 
                            placeholder="Noms des personnes consultées (séparés par des virgules)"
                            onchange="updateRACI('${reg.id}', 'consulted', this.value)">
                    </div>
                </div>
                <div class="raci-row">
                    <div class="raci-label">Informés (I):</div>
                    <div class="raci-input">
                        <input type="text" 
                            class="input" 
                            id="informed-${reg.id}" 
                            value="${reg.informed || ''}" 
                            placeholder="Noms des personnes informées (séparés par des virgules)"
                            onchange="updateRACI('${reg.id}', 'informed', this.value)">
                    </div>
                </div>
            </div>
        </div>
    `;
}

function updateRACI(regulationId, raciType, value) {
    regulations = regulations.map(reg => {
        if (reg.id === regulationId) {
            return {
                ...reg,
                [raciType]: value
            };
        }
        return reg;
    });
    autoSave();
}

document.addEventListener('DOMContentLoaded', () => {
    autoLoad();
    initializeWall();
    renderRegulations(true);
    document.getElementById('searchInput').addEventListener('input', handleSearchInput);
    document.getElementById('categoryFilters').addEventListener('click', handleCategoryFilter);
    document.getElementById('statusTabs').addEventListener('click', handleStatusTabClick);
    renderRegulations();
});

function getRiskLevelClass(level) {
    if (level >= 15) return 'high';
    if (level >= 8) return 'medium';
    return 'low';
}

function updateCategory(regulationId, selectedCategory) {
    regulations = regulations.map(reg => {
        if (reg.id === regulationId) {
            return {
                ...reg,
                isCompliant: selectedCategory === 'Compliant',
                isApplicable: selectedCategory === 'Applicable',
                isDocumentation: selectedCategory === 'Documentation'
            };
        }
        return reg;
    });
    renderRegulations();
    autoSave();
}


// Ajouter au début du script existant dans l'index.html

// Création du Web Worker inline
const workerScript = `
    let regulations = [];
    let filteredRegs = [];
    const BATCH_SIZE = 10;

    self.onmessage = function(e) {
        const { type, data } = e.data;
        
        switch (type) {
            case 'INIT_DATA':
                regulations = data.regulations;
                filterAndSendBatch(0);
                break;
                
            case 'FILTER_UPDATE':
                const { searchTerm, activeFilter, activeStatus } = data;
                filterRegulations(searchTerm, activeFilter, activeStatus);
                break;
                
            case 'REQUEST_BATCH':
                const { startIndex } = data;
                filterAndSendBatch(startIndex);
                break;
        }
    };

    function filterRegulations(searchTerm, activeFilter, activeStatus) {
        filteredRegs = regulations.filter(reg => {
            // Filtrage par recherche
            if (searchTerm) {
                const searchLower = searchTerm.toLowerCase();
                const inText = reg.text.toLowerCase().includes(searchLower);
                const inId = reg.id.toLowerCase().includes(searchLower);
                const inActions = reg.actions.some(action => {
                    return action.text.toLowerCase().includes(searchLower) ||
                           (action.assignedTo && action.assignedTo.toLowerCase().includes(searchLower)) ||
                           (action.raci?.responsible && action.raci.responsible.toLowerCase().includes(searchLower));
                });
                
                if (!inText && !inId && !inActions) return false;
            }

            // Filtrage par catégorie
            if (activeFilter !== 'all' && reg.category !== activeFilter) {
                return false;
            }

            // Filtrage par statut
            if (activeStatus === 'A faire') {
                const totalProgress = reg.actions.reduce((sum, action) => sum + (action.percentage || 0), 0);
                if (totalProgress > 0) return false;
            } else if (activeStatus === 'En cours') {
                const totalProgress = reg.actions.reduce((sum, action) => sum + (action.percentage || 0), 0);
                if (totalProgress === 0) return false;
            } else if (activeStatus !== 'all' && reg.status !== activeStatus) {
                return false;
            }

            return true;
        });

        // Calculer la conformité
        const complianceRate = calculateCompliance(filteredRegs);
        
        // Envoyer les métadonnées
        self.postMessage({
            type: 'METADATA_UPDATE',
            data: {
                total: filteredRegs.length,
                complianceRate
            }
        });

        // Envoyer le premier lot
        filterAndSendBatch(0);
    }

    function calculateCompliance(regList) {
        let totalCompliance = 0;
        let totalApplicable = 0;
        
        regList.forEach(reg => {
            if (reg.status === 'Non Applicable' || reg.status === 'Documentation') return;
            totalApplicable++;
            
            if (reg.status === 'Compliant') {
                totalCompliance += 100;
            } else if (reg.actions.length > 0) {
                const totalActionProgress = reg.actions.reduce((sum, action) => 
                    sum + (action.percentage || 0), 0);
                const averageProgress = totalActionProgress / reg.actions.length;
                totalCompliance += averageProgress;
            }
        });
        
        return totalApplicable ? (totalCompliance / totalApplicable).toFixed(1) : '0.0';
    }

    function filterAndSendBatch(startIndex) {
        const endIndex = startIndex + BATCH_SIZE;
        const batch = filteredRegs.slice(startIndex, endIndex);
        const hasMore = endIndex < filteredRegs.length;

        self.postMessage({
            type: 'BATCH_READY',
            data: {
                items: batch,
                total: filteredRegs.length,
                hasMore: hasMore,
                startIndex: startIndex
            }
        });
    }
`;

// Créer le Worker à partir du script
const workerBlob = new Blob([workerScript], { type: 'application/javascript' });
const workerUrl = URL.createObjectURL(workerBlob);

// Variables globales pour la pagination
let hasMoreItems = true;
let dataWorker = null;

// Initialisation du worker et du système de chargement progressif
function initializeWall() {
    // Créer et configurer le worker
    dataWorker = new Worker(workerUrl);
    
    // Gestionnaire des messages du worker
    dataWorker.onmessage = function(e) {
        const { type, data } = e.data;
        if (type === 'BATCH_READY') {
            renderBatch(data);
        } else if (type === 'METADATA_UPDATE') {
            updateMetadata(data);
        }
    };

    // Initialiser avec les données actuelles
    dataWorker.postMessage({
        type: 'INIT_DATA',
        data: { regulations }
    });

    // Configurer l'observateur d'intersection
    setupIntersectionObserver();
}

// Nettoyage à la fermeture
window.addEventListener('beforeunload', () => {
    if (dataWorker) {
        dataWorker.terminate();
    }
    URL.revokeObjectURL(workerUrl);
});

// Modification des gestionnaires d'événements existants
function handleSearchInput(event) {
    if (!dataWorker) return;
    
    dataWorker.postMessage({
        type: 'FILTER_UPDATE',
        data: {
            searchTerm: event.target.value,
            activeFilter,
            activeStatus
        }
    });
}

function handleCategoryFilter(event) {
    if (!event.target.classList.contains('category-filter') || !dataWorker) return;
    
    document.querySelectorAll('.category-filter').forEach(filter => 
        filter.classList.remove('active'));
    event.target.classList.add('active');
    activeFilter = event.target.dataset.category;
    
    dataWorker.postMessage({
        type: 'FILTER_UPDATE',
        data: {
            searchTerm: document.getElementById('searchInput').value,
            activeFilter,
            activeStatus
        }
    });
}

function handleStatusTabClick(event) {
    if (!event.target.classList.contains('tab') || !dataWorker) return;
    
    document.querySelectorAll('.tab').forEach(tab => 
        tab.classList.remove('active'));
    event.target.classList.add('active');
    activeStatus = event.target.dataset.status;
    
    dataWorker.postMessage({
        type: 'FILTER_UPDATE',
        data: {
            searchTerm: document.getElementById('searchInput').value,
            activeFilter,
            activeStatus
        }
    });
}

// Fonction pour charger le prochain lot
function loadNextBatch() {
    if (isLoading || !hasMoreItems) return;
    
    isLoading = true;
    
    // Demander le prochain lot au worker
    dataWorker.postMessage({
        type: 'REQUEST_BATCH',
        data: { 
            startIndex: currentPage * 10 // 10 éléments par lot
        }
    });
}

// Fonction pour rendre un lot
// Fonction pour rendre un lot d'articles
function renderBatch(regulations, reset) {
    const container = document.getElementById('wallItems');
    
    if (reset) {
        container.innerHTML = '';
    }

    regulations.forEach(reg => {
        const regulationElement = document.createElement('div');
        regulationElement.className = 'regulation-item fade-in';
        regulationElement.id = `regulation-${reg.id}`;
        regulationElement.innerHTML = renderRegulationContent(reg);
        container.appendChild(regulationElement);
    });

    setupIntersectionObserver();
}


// Helper fonction pour créer l'élément de régulation
function createRegulationElement(regulation) {
    const element = document.createElement('div');
    element.className = 'regulation-item';
    element.id = `regulation-${regulation.id}`;
    
    // Réutiliser votre code HTML existant pour la structure de l'élément
    element.innerHTML = `
        <div class="regulation-header">
            ${renderRegulationContent(regulation)}
        </div>
    `;

    return element;
}

// Variables globales pour le suivi des statistiques
let globalStats = {
    totalItems: 0,
    visibleItems: 0,
    compliantCount: 0,
    inProgressCount: 0,
    complianceRate: 0
};

function updateMetadata(currentBatch) {
    // Mise à jour des statistiques pour le lot actuel
    let batchStats = currentBatch.reduce((stats, reg) => {
        // Compter les éléments par statut
        if (reg.status === 'Compliant') {
            stats.compliantCount++;
        } else if (reg.actions && reg.actions.some(action => action.percentage > 0)) {
            stats.inProgressCount++;
        }

        // Calculer le taux de conformité pour cet élément
        if (reg.status !== 'Non Applicable' && reg.status !== 'Documentation') {
            stats.applicableCount++;
            if (reg.status === 'Compliant') {
                stats.complianceTotal += 100;
            } else if (reg.actions.length > 0) {
                const avgProgress = reg.actions.reduce((sum, action) => 
                    sum + (action.percentage || 0), 0) / reg.actions.length;
                stats.complianceTotal += avgProgress;
            }
        }

        return stats;
    }, {
        compliantCount: 0,
        inProgressCount: 0,
        applicableCount: 0,
        complianceTotal: 0
    });

    // Mettre à jour les statistiques globales
    globalStats.totalItems = regulations.length;
    globalStats.visibleItems = currentBatch.length;
    globalStats.compliantCount = batchStats.compliantCount;
    globalStats.inProgressCount = batchStats.inProgressCount;
    
    // Calculer le taux de conformité
    const complianceRate = batchStats.applicableCount > 0 
        ? (batchStats.complianceTotal / batchStats.applicableCount).toFixed(1) 
        : '0.0';

    // Mettre à jour l'interface
    updateUI(complianceRate, batchStats);
}

function updateUI(complianceRate, stats) {
    // Mettre à jour le taux de conformité
    const complianceElement = document.querySelector('.compliance-rate');
    if (complianceElement) {
        complianceElement.textContent = `Taux de conformité: ${complianceRate}%`;
    }

    // Mettre à jour le compteur d'éléments visibles
    const countElement = document.createElement('div');
    countElement.className = 'items-count';
    countElement.textContent = `Affichage de ${globalStats.visibleItems} sur ${globalStats.totalItems} éléments`;
    
    // Insérer le compteur après le taux de conformité
    if (complianceElement && !document.querySelector('.items-count')) {
        complianceElement.insertAdjacentElement('afterend', countElement);
    }

    // Mettre à jour les badges de statut
    updateStatusBadges(stats);
}

function updateStatusBadges(stats) {
    const badges = {
        compliant: `<span class="badge badge-success">Compliant: ${stats.compliantCount}</span>`,
        inProgress: `<span class="badge badge-warning">En cours: ${stats.inProgressCount}</span>`,
        total: `<span class="badge badge-info">Total visible: ${globalStats.visibleItems}</span>`
    };

    // Créer ou mettre à jour le conteneur de badges
    let badgesContainer = document.querySelector('.status-badges');
    if (!badgesContainer) {
        badgesContainer = document.createElement('div');
        badgesContainer.className = 'status-badges';
        document.querySelector('.header').appendChild(badgesContainer);
    }

    badgesContainer.innerHTML = Object.values(badges).join('');
}

// Style pour les nouveaux éléments
const metadataStyles = `
    .items-count {
        color: var(--gray-600);
        font-size: 0.875rem;
        margin-bottom: var(--space-4);
    }

    .status-badges {
        display: flex;
        gap: var(--space-2);
        margin-bottom: var(--space-4);
        flex-wrap: wrap;
    }

    .badge {
        padding: var(--space-1) var(--space-2);
        border-radius: var(--radius-sm);
        font-size: 0.75rem;
        font-weight: 500;
    }

    .badge-success {
        background-color: var(--success-50);
        color: var(--success-600);
    }

    .badge-warning {
        background-color: var(--warning-50);
        color: var(--warning-600);
    }

    .badge-info {
        background-color: var(--primary-50);
        color: var(--primary-600);
    }
`;

// Ajouter les styles
function addMetadataStyles() {
    const style = document.createElement('style');
    style.textContent = metadataStyles;
    document.head.appendChild(style);
}

// Initialisation
document.addEventListener('DOMContentLoaded', addMetadataStyles);


// Variables globales
let isOffline = false;


// Fonction de chargement des régulations
async function loadRegulations(reset = false) {
    if (isLoading) return;
    isLoading = true;

    try {
        showLoadingIndicator();

        if (reset) {
            document.getElementById('wallItems').innerHTML = '';
            lastDoc = null;
        }

        // Construire la requête
        let query = db.collection('regulations')
            .orderBy('createdAt', 'desc')
            .limit(BATCH_SIZE);

        if (lastDoc && !reset) {
            query = query.startAfter(lastDoc);
        }

        const snapshot = await query.get();
        
        if (!snapshot.empty) {
            lastDoc = snapshot.docs[snapshot.docs.length - 1];
            const regulations = snapshot.docs.map(doc => ({
                id: doc.id,
                ...doc.data()
            }));

            // Envoyer les données au worker
            if (dataWorker) {
                dataWorker.postMessage({
                    type: 'BATCH_READY',
                    data: {
                        items: regulations,
                        total: snapshot.size,
                        hasMore: regulations.length === BATCH_SIZE,
                        startIndex: reset ? 0 : document.querySelectorAll('.regulation-item').length
                    }
                });
            } else {
                // Fallback si le worker n'est pas disponible
                renderBatch({
                    items: regulations,
                    total: snapshot.size,
                    hasMore: regulations.length === BATCH_SIZE,
                    startIndex: reset ? 0 : document.querySelectorAll('.regulation-item').length
                });
            }
        } else {
            if (reset) {
                document.getElementById('wallItems').innerHTML = 
                    '<div class="no-data">Aucune donnée trouvée</div>';
            }
            hideLoadMoreButton();
        }

    } catch (error) {
        console.error('Erreur de chargement:', error);
        showNotification('Erreur lors du chargement des données', 'error');
    } finally {
        isLoading = false;
        hideLoadingIndicator();
    }
}

// Fonctions utilitaires pour l'interface
function showLoadingIndicator() {
    const indicator = document.createElement('div');
    indicator.className = 'loading-indicator';
    indicator.innerHTML = '<div class="spinner"></div>';
    document.getElementById('wallItems').appendChild(indicator);
}

function hideLoadingIndicator() {
    const indicator = document.querySelector('.loading-indicator');
    if (indicator) {
        indicator.remove();
    }
}

// Gestion de l'interface de chargement
function hideLoadMoreButton() {
    const button = document.querySelector('.load-more');
    if (button) {
        button.remove();
    }
}

// Gestion de l'état offline
function updateOfflineStatus(offline) {
    isOffline = offline;
    const statusBadge = document.getElementById('connection-status') || 
                       document.createElement('div');
    statusBadge.id = 'connection-status';
    statusBadge.className = `status-badge ${offline ? 'offline' : 'online'}`;
    statusBadge.textContent = offline ? 'Hors ligne' : 'En ligne';
    
    document.querySelector('.header').appendChild(statusBadge);
}

// Gestion des erreurs
function handleLoadError(error) {
    let message = 'Une erreur est survenue';
    
    if (error.code === 'unavailable') {
        message = 'La connexion au serveur est impossible. Mode hors ligne activé.';
    } else if (error.code === 'permission-denied') {
        message = 'Accès non autorisé. Vérifiez les règles de sécurité.';
    }

    const errorDiv = document.createElement('div');
    errorDiv.className = 'error-message';
    errorDiv.textContent = message;
    
    const container = document.getElementById('wallItems');
    container.insertBefore(errorDiv, container.firstChild);
}

// Indicateurs de chargement
function addLoadingIndicator() {
    const indicator = document.createElement('div');
    indicator.className = 'loading-indicator';
    indicator.innerHTML = `
        <div class="spinner"></div>
        <div class="loading-text">Chargement...</div>
    `;
    document.getElementById('wallItems').appendChild(indicator);
    return indicator;
}

function removeLoadingIndicator() {
    const indicator = document.querySelector('.loading-indicator');
    if (indicator) indicator.remove();
}

// Styles pour les indicateurs
const styles = `
    .status-badge {
        position: fixed;
        top: 20px;
        right: 20px;
        padding: 8px 16px;
        border-radius: 4px;
        font-weight: 500;
        z-index: 1000;
    }
    
    .status-badge.online {
        background-color: var(--success-50);
        color: var(--success-600);
    }
    
    .status-badge.offline {
        background-color: var(--danger-50);
        color: var(--danger-600);
    }

    .loading-indicator {
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 20px;
        gap: 10px;
    }

    .spinner {
        width: 20px;
        height: 20px;
        border: 2px solid var(--gray-200);
        border-top-color: var(--primary-500);
        border-radius: 50%;
        animation: spin 1s linear infinite;
    }

    .error-message {
        background-color: var(--danger-50);
        color: var(--danger-600);
        padding: 12px;
        border-radius: 4px;
        margin: 12px 0;
    }

    @keyframes spin {
        to { transform: rotate(360deg); }
    }
    .global-loader {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(255, 255, 255, 0.8);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 1000;
    }

    .loader-spinner {
        width: 40px;
        height: 40px;
        border: 4px solid var(--gray-200);
        border-top-color: var(--primary-500);
        border-radius: 50%;
        animation: spin 1s linear infinite;
    }

    .load-sentinel {
        height: 20px;
        margin: 20px 0;
    }

    .fade-in {
        opacity: 0;
        animation: fadeIn 0.3s ease forwards;
    }

    @keyframes spin {
        to { transform: rotate(360deg); }
    }

    @keyframes fadeIn {
        to { opacity: 1; }
    }
`;

// Ajouter les styles
const styleSheet = document.createElement('style');
styleSheet.textContent = styles;
document.head.appendChild(styleSheet);

// Initialisation au chargement de la page
document.addEventListener('DOMContentLoaded', () => {
    resetAndReload();
});

        // Configuration Firebase en dur
        const firebaseConfig = {
          apiKey: "AIzaSyCTkHkB4fwTYaid1ly_Wv50_VE9dyTVGEg",
          authDomain: "mydora-5767a.firebaseapp.com",
          projectId: "mydora-5767a",
          storageBucket: "mydora-5767a.firebasestorage.app",
          messagingSenderId: "716389188012",
          appId: "1:716389188012:web:e72fbdf6931b56a55d3a09"
        };

        // Initialisation automatique de Firebase
        (function initializeFirebase() {
            try {
                if (!firebase.apps.length) {
                    firebase.initializeApp(firebaseConfig);
                    db = firebase.firestore(); // Initialise Firestore
                } else {
                    console.log("Firebase est déjà initialisé");
                }
            } catch (error) {
                console.error("Erreur d'initialisation de Firebase :", error);
            }
        })();

// Utilitaires pour la gestion des erreurs et notifications
function showError(message) {
    const errorDiv = document.createElement('div');
    errorDiv.className = 'error-notification';
    errorDiv.textContent = message;
    document.body.appendChild(errorDiv);
    setTimeout(() => errorDiv.remove(), 3000);
}

function showNotification(message, type) {
    const notification = document.createElement('div');
    notification.className = `notification ${type}`;
    notification.textContent = message;
    document.body.appendChild(notification);
    setTimeout(() => notification.remove(), 3000);
}
        
async function publishArticle(article) {
    const db = firebase.firestore();
    try {
        // Ajoute un article à la collection "articles"
        await db.collection("articles").add({
            title: article.title,
            content: article.content,
            createdAt: firebase.firestore.FieldValue.serverTimestamp()
        });
        console.log("Article publié avec succès");
    } catch (error) {
        console.error("Erreur lors de la publication de l'article :", error);
    }
}

// Styles globaux pour l'application
const globalStyles = `
    .notification {
        position: fixed;
        top: 20px;
        right: 20px;
        padding: 12px 20px;
        border-radius: 4px;
        z-index: 1000;
        animation: slideIn 0.3s ease;
    }

    .notification.success {
        background-color: var(--success-50);
        color: var(--success-600);
    }

    .notification.error {
        background-color: var(--danger-50);
        color: var(--danger-600);
    }

    .loading-indicator {
        display: flex;
        justify-content: center;
        padding: 20px;
    }

    .spinner {
        width: 30px;
        height: 30px;
        border: 3px solid var(--gray-200);
        border-top-color: var(--primary-500);
        border-radius: 50%;
        animation: spin 1s linear infinite;
    }

    @keyframes spin {
        to { transform: rotate(360deg); }
    }

    @keyframes slideIn {
        from { transform: translateX(100%); }
        to { transform: translateX(0); }
    }

    .load-more {
        display: block;
        margin: 20px auto;
        padding: 8px 16px;
    }

    .load-sentinel {
        height: 20px;
        margin: 20px 0;
    }
`;

// Fonction pour ajouter les styles
function addStyles() {
    const styleElement = document.createElement('style');
    styleElement.textContent = globalStyles;
    document.head.appendChild(styleElement);
}

// Code du Worker
const workerCode = `
    let regulations = [];
    let filteredRegs = [];
    
    self.onmessage = function(e) {
        const { type, data } = e.data;
        
        switch (type) {
            case 'INIT_DATA':
                regulations = data.regulations || [];
                filterAndSendBatch(0);
                break;
                
            case 'FILTER_UPDATE':
                const { searchTerm, activeFilter, activeStatus } = data;
                filterRegulations(searchTerm, activeFilter, activeStatus);
                break;
                
            case 'REQUEST_BATCH':
                const { startIndex } = data;
                filterAndSendBatch(startIndex);
                break;
                
            case 'BATCH_READY':
                // Traiter directement les données reçues de Firestore
                self.postMessage({
                    type: 'RENDER_BATCH',
                    data: data
                });
                break;
        }
    };

    function filterRegulations(searchTerm, activeFilter, activeStatus) {
        filteredRegs = regulations.filter(reg => {
            if (searchTerm) {
                const searchLower = searchTerm.toLowerCase();
                const inText = reg.text.toLowerCase().includes(searchLower);
                const inId = reg.id.toLowerCase().includes(searchLower);
                return inText || inId;
            }
            return true;
        });

        if (activeFilter !== 'all') {
            filteredRegs = filteredRegs.filter(reg => reg.category === activeFilter);
        }

        if (activeStatus !== 'all') {
            filteredRegs = filteredRegs.filter(reg => reg.status === activeStatus);
        }

        filterAndSendBatch(0);
    }

    function filterAndSendBatch(startIndex) {
        const batchSize = 10;
        const endIndex = startIndex + batchSize;
        const batch = filteredRegs.slice(startIndex, endIndex);
        
        self.postMessage({
            type: 'RENDER_BATCH',
            data: {
                items: batch,
                total: filteredRegs.length,
                hasMore: endIndex < filteredRegs.length,
                startIndex: startIndex
            }
        });
    }
`;

// Création et initialisation du Worker
function initializeWorker() {
    const blob = new Blob([workerCode], { type: 'application/javascript' });
    const workerUrl = URL.createObjectURL(blob);
    const worker = new Worker(workerUrl);
    
    worker.onmessage = function(e) {
        const { type, data } = e.data;
        if (type === 'RENDER_BATCH') {
            renderBatch(data);
        }
    };
    
    return worker;
}

// Fonction de rendu modifiée
function renderBatch(data) {
    if (!data || !data.items || !Array.isArray(data.items)) {
        console.error('Invalid data received:', data);
        return;
    }

    const container = document.getElementById('wallItems');
    
    if (data.startIndex === 0) {
        container.innerHTML = '';
    }

    data.items.forEach(reg => {
        const articleElement = document.createElement('div');
        articleElement.className = 'regulation-item fade-in';
        articleElement.id = `regulation-${reg.id}`;
        articleElement.innerHTML = renderRegulationContent(reg);
        container.appendChild(articleElement);
    });

    if (data.hasMore) {
        setupIntersectionObserver();
    }

    updateStats(data.total);
}

// Initialisation
document.addEventListener('DOMContentLoaded', () => {
    addStyles();
    const dataWorker = initializeWorker();
    loadRegulations(true);
    setupIntersectionObserver();
    
    // Event listeners pour la recherche et les filtres
    document.getElementById('searchInput')?.addEventListener('input', e => {
        dataWorker.postMessage({
            type: 'FILTER_UPDATE',
            data: {
                searchTerm: e.target.value,
                activeFilter,
                activeStatus
            }
        });
    });
});

// Fonction pour initialiser Firebase et vérifier/créer la collection
async function initializeFirebase() {
    try {
        if (!firebase.apps.length) {
            firebase.initializeApp(firebaseConfig);
            db = firebase.firestore();
            console.log("Firebase initialisé avec succès");
            
            // Vérifier si la collection existe
            const regulations = await db.collection('regulations').get();
            console.log("Collection vérifiée ou créée");
        }
    } catch (error) {
        console.error("Erreur d'initialisation:", error);
        showNotification('Erreur de connexion à Firebase', 'error');
    }
}

// Fonction modifiée pour ajouter un nouvel article avec vérification
async function addNewArticle() {
    try {
        showLoading();

        // Récupérer les valeurs du formulaire
        const category = document.getElementById('articleCategory').value;
        const reference = document.getElementById('articleReference').value;
        const text = document.getElementById('articleText').value;
        
        // Validation
        if (!category || !reference || !text) {
            showNotification('Tous les champs sont obligatoires', 'error');
            return;
        }

        // Créer l'article de test
        const testDoc = {
            id: `${reference}-test`,
            category: category,
            text: text,
            createdAt: firebase.firestore.FieldValue.serverTimestamp()
        };

        // Test d'écriture
        console.log("Tentative d'écriture:", testDoc);
        const docRef = await db.collection('regulations').add(testDoc);
        console.log("Document écrit avec ID:", docRef.id);

        // Si le test réussit, procéder avec les vrais articles
        const parsedRequirements = parseRequirementsFromText(text);
        const batch = db.batch();

        for (const req of parsedRequirements) {
            const articleId = `${reference}-${req.id}`;
            const articleRef = db.collection('regulations').doc(articleId);
            
            const articleData = {
                id: articleId,
                category: category,
                text: req.originalText,
                fullPath: req.id,
                parentChain: req.parentChain,
                status: 'all',
                actions: [],
                createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                // Autres champs RACI
                responsible: '',
                accountable: '',
                consulted: '',
                informed: ''
            };

            if (category === 'Level 1') {
                articleData.rtsLinks = document.getElementById('rtsLink').value
                    .split(',').map(s => s.trim()).filter(Boolean);
                articleData.itsLinks = document.getElementById('itsLink').value
                    .split(',').map(s => s.trim()).filter(Boolean);
            } else if (category === 'RTS' || category === 'ITS') {
                articleData.level1Link = document.getElementById('level1Link').value.trim();
            }

            batch.set(articleRef, articleData);
            console.log("Article préparé:", articleData);
        }

        // Exécuter le batch
        await batch.commit();
        console.log("Batch commité avec succès");

        showNotification('Articles ajoutés avec succès', 'success');
        resetArticleForm();
        
        // Recharger les articles
        await loadRegulations(true);

    } catch (error) {
        console.error('Erreur lors de l\'ajout:', error);
        showNotification(`Erreur: ${error.message}`, 'error');
    } finally {
        hideLoading();
    }
}

// Fonction de vérification de la connexion Firestore
async function checkFirestoreConnection() {
    try {
        const timestamp = await db.collection('regulations')
            .add({
                test: true,
                timestamp: firebase.firestore.FieldValue.serverTimestamp()
            });
        await timestamp.delete();
        console.log("Connexion Firestore OK");
        return true;
    } catch (error) {
        console.error("Erreur de connexion Firestore:", error);
        return false;
    }
}

// Initialisation avec vérifications
document.addEventListener('DOMContentLoaded', async () => {
    try {
        await initializeFirebase();
        const isConnected = await checkFirestoreConnection();
        
        if (!isConnected) {
            showNotification('Erreur de connexion à la base de données', 'error');
            return;
        }

        showNotification('Connecté à la base de données', 'success');
        await loadRegulations(true);
        
        // Event listeners
        document.getElementById('searchInput').addEventListener('input', handleSearchInput);
        document.getElementById('categoryFilters').addEventListener('click', handleCategoryFilter);
        document.getElementById('statusTabs').addEventListener('click', handleStatusTabClick);
        
    } catch (error) {
        console.error("Erreur d'initialisation:", error);
        showNotification('Erreur de démarrage de l\'application', 'error');
    }
});

// Fonction pour afficher les notifications plus visibles
function showNotification(message, type = 'info') {
    const notification = document.createElement('div');
    notification.className = `notification ${type}`;
    notification.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        padding: 15px 25px;
        background: ${type === 'error' ? '#fee2e2' : '#ecfdf5'};
        color: ${type === 'error' ? '#dc2626' : '#059669'};
        border-radius: 6px;
        box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        z-index: 1000;
        font-weight: 500;
    `;
    notification.textContent = message;
    
    document.body.appendChild(notification);
    console.log(type === 'error' ? `Erreur: ${message}` : message);
    
    setTimeout(() => {
        notification.remove();
    }, 5000);
}

// Fonctions d'aide pour l'interface
function showLoading() {
    const loader = document.createElement('div');
    loader.className = 'global-loader';
    loader.innerHTML = `
        <div style="
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            display: flex;
            align-items: center;
            gap: 10px;
        ">
            <div class="spinner"></div>
            <span>Chargement...</span>
        </div>
    `;
    document.body.appendChild(loader);
}

function hideLoading() {
    const loader = document.querySelector('.global-loader');
    if (loader) {
        loader.remove();
    }
}


// Fonction de lecture des données avec pagination
async function loadRegulations(reset = false) {
    if (isLoading) return;
    isLoading = true;
    showLoading();

    try {
        if (reset) {
            document.getElementById('wallItems').innerHTML = '';
            lastDoc = null;
        }

        // Construire la requête de base
        let query = db.collection('regulations')
            .orderBy('createdAt', 'desc')
            .limit(BATCH_SIZE);

        // Ajouter le startAfter si ce n'est pas un reset
        if (!reset && lastDoc) {
            query = query.startAfter(lastDoc);
        }

        const snapshot = await query.get();
        
        if (!snapshot.empty) {
            // Sauvegarder le dernier document pour la pagination
            lastDoc = snapshot.docs[snapshot.docs.length - 1];
            
            // Convertir les documents en données
            const regulations = snapshot.docs.map(doc => ({
                id: doc.id,
                ...doc.data()
            }));

            // Rendre les données
            renderRegulations(regulations, reset);
            
            // Configurer l'observateur pour le chargement infini
            setupIntersectionObserver();

            showNotification(`${regulations.length} articles chargés`, 'success');
        } else {
            if (reset) {
                document.getElementById('wallItems').innerHTML = 
                    '<div class="no-data">Aucune donnée trouvée</div>';
            }
        }

    } catch (error) {
        console.error('Erreur de chargement:', error);
        showNotification('Erreur lors du chargement des données', 'error');
    } finally {
        isLoading = false;
        hideLoading();
    }
}

// Fonction de rendu des régulations
function renderRegulations(regulations, reset = false) {
    const container = document.getElementById('wallItems');
    
    // Si reset, vider le conteneur
    if (reset) {
        container.innerHTML = '';
    }

    // Calculer le taux de conformité
    let complianceRate = calculateCompliance(regulations);
    updateComplianceRate(complianceRate);

    // Rendre chaque régulation
    regulations.forEach(reg => {
        const regulationElement = document.createElement('div');
        regulationElement.className = 'regulation-item fade-in';
        regulationElement.id = `regulation-${reg.id}`;
        regulationElement.innerHTML = `
            <div class="regulation-header">
                <div class="status-controls">
                    <label>
                        <input type="radio" 
                            name="status-${reg.id}" 
                            class="checkbox" 
                            value="Compliant" 
                            ${reg.status === 'Compliant' ? 'checked' : ''} 
                            onchange="updateStatus('${reg.id}', 'Compliant')"> Compliant
                    </label>
                    <label>
                        <input type="radio" 
                            name="status-${reg.id}" 
                            value="Non Applicable" 
                            ${reg.status === 'Non Applicable' ? 'checked' : ''} 
                            onchange="updateStatus('${reg.id}', 'Non Applicable')"> Non Applicable
                    </label>
                    <label>
                        <input type="radio" 
                            name="status-${reg.id}" 
                            value="Documentation" 
                            ${reg.status === 'Documentation' ? 'checked' : ''} 
                            onchange="updateStatus('${reg.id}', 'Documentation')"> Documentation
                    </label>
                </div>
            </div>
            <div class="regulation-content">
                <div class="regulation-text">${reg.text}</div>
                <div class="regulation-id"><i>${reg.id}</i></div>
                ${renderLinks(reg)}
                ${renderRACI(reg)}
                ${renderActions(reg)}
                ${renderJustification(reg)}
                ${renderProofLinks(reg)}
                
                <div class="action-buttons">
                    <button class="button secondary" onclick="editRegulation('${reg.id}')">Éditer</button>
                    <button class="button secondary" onclick="deleteRegulation('${reg.id}')">Supprimer</button>
                </div>
            </div>
        `;
        
        container.appendChild(regulationElement);
    });
}

// Fonction de recherche et filtrage
async function searchAndFilter(searchTerm, filter, status) {
    showLoading();
    try {
        // Construire la requête de base
        let query = db.collection('regulations');

        // Appliquer les filtres
        if (filter !== 'all') {
            query = query.where('category', '==', filter);
        }
        if (status !== 'all' && status !== 'Exigences with Risks') {
            query = query.where('status', '==', status);
        }

        // Exécuter la requête
        const snapshot = await query.get();
        let results = snapshot.docs.map(doc => ({
            id: doc.id,
            ...doc.data()
        }));

        // Filtrage côté client pour la recherche textuelle
        if (searchTerm) {
            results = results.filter(reg => 
                reg.text.toLowerCase().includes(searchTerm.toLowerCase()) ||
                reg.id.toLowerCase().includes(searchTerm.toLowerCase())
            );
        }

        // Filtrage spécial pour "Exigences with Risks"
        if (status === 'Exigences with Risks') {
            results = results.filter(reg => 
                reg.actions && reg.actions.some(action => 
                    action.risks && action.risks.length > 0
                )
            );
        }

        // Rendre les résultats
        renderRegulations(results, true);

    } catch (error) {
        console.error('Erreur de recherche:', error);
        showNotification('Erreur lors de la recherche', 'error');
    } finally {
        hideLoading();
    }
}

// Configuration de l'Intersection Observer pour le lazy loading
function setupIntersectionObserver() {
    const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
            if (entry.isIntersecting && !isLoading && lastDoc) {
                loadRegulations(false);
            }
        });
    }, {
        rootMargin: '100px'
    });

    let sentinel = document.querySelector('.load-sentinel');
    if (!sentinel) {
        sentinel = document.createElement('div');
        sentinel.className = 'load-sentinel';
        document.getElementById('wallItems').appendChild(sentinel);
    }

    observer.observe(sentinel);
}

// Mise à jour d'une régulation dans Firestore
async function updateRegulation(id, updates) {
    try {
        await db.collection('regulations').doc(id).update(updates);
        showNotification('Mise à jour réussie', 'success');
    } catch (error) {
        console.error('Erreur de mise à jour:', error);
        showNotification('Erreur lors de la mise à jour', 'error');
    }
}

// Fonction de mise à jour du taux de conformité
function updateComplianceRate(rate) {
    const element = document.querySelector('.compliance-rate');
    if (element) {
        element.textContent = `Taux de conformité: ${rate}%`;
    }
}


// Utilitaire pour debounce
function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
        const later = () => {
            timeout = null;
            func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
    };
}

// Event listeners
document.addEventListener('DOMContentLoaded', () => {
    // Charger les données initiales
    loadRegulations(true);

    // Gestionnaires d'événements pour les filtres
    document.getElementById('searchInput').addEventListener('input', debounce((e) => {
        searchAndFilter(
            e.target.value,
            activeFilter,
            activeStatus
        );
    }, 300));

    document.getElementById('categoryFilters').addEventListener('click', (e) => {
        if (e.target.classList.contains('category-filter')) {
            activeFilter = e.target.dataset.category;
            searchAndFilter(
                document.getElementById('searchInput').value,
                activeFilter,
                activeStatus
            );
        }
    });

    document.getElementById('statusTabs').addEventListener('click', (e) => {
        if (e.target.classList.contains('tab')) {
            activeStatus = e.target.dataset.status;
            searchAndFilter(
                document.getElementById('searchInput').value,
                activeFilter,
                activeStatus
            );
        }
    });
});

// Fonction de calcul de conformité corrigée
function calculateCompliance(regList) {
    // Vérifier que regList est un tableau
    if (!Array.isArray(regList)) {
        console.error('Liste de régulations invalide:', regList);
        return '0.0';
    }

    let totalCompliance = 0;
    let totalApplicable = 0;

    regList.forEach(reg => {
        // Vérifier que reg est un objet valide
        if (!reg || typeof reg !== 'object') return;

        if (reg.status === 'Non Applicable' || reg.status === 'Documentation') return;
        
        totalApplicable++;
        if (reg.status === 'Compliant') {
            totalCompliance += 100;
        } else {
            if (Array.isArray(reg.actions) && reg.actions.length > 0) {
                const totalActionProgress = reg.actions.reduce((sum, action) => {
                    return sum + (Number(action.percentage) || 0);
                }, 0);
                const averageProgress = totalActionProgress / reg.actions.length;
                totalCompliance += averageProgress;
            }
        }
    });

    return totalApplicable ? (totalCompliance / totalApplicable).toFixed(1) : '0.0';
}

// Fonction de rendu modifiée
function renderRegulations(regulations, reset = false) {
    const container = document.getElementById('wallItems');
    
    // Vérifier que regulations est un tableau
    if (!Array.isArray(regulations)) {
        console.error('Données de régulations invalides:', regulations);
        container.innerHTML = '<div class="error">Erreur de chargement des données</div>';
        return;
    }
    
    if (reset) {
        container.innerHTML = '';
    }

    // Calculer et mettre à jour le taux de conformité
    const complianceRate = calculateCompliance(regulations);
    const complianceElement = document.querySelector('.compliance-rate');
    if (complianceElement) {
        complianceElement.textContent = `Taux de conformité: ${complianceRate}%`;
    }

    // Rendre chaque régulation
    regulations.forEach(reg => {
        if (!reg || typeof reg !== 'object') return;

        const regulationElement = document.createElement('div');
        regulationElement.className = 'regulation-item fade-in';
        regulationElement.id = `regulation-${reg.id}`;
        regulationElement.innerHTML = `
            <div class="regulation-header">
                <div class="status-controls">
                    <label>
                        <input type="radio" 
                            name="status-${reg.id}" 
                            class="checkbox" 
                            value="Compliant" 
                            ${reg.status === 'Compliant' ? 'checked' : ''} 
                            onchange="updateStatus('${reg.id}', 'Compliant')"> Compliant
                    </label>
                    <label>
                        <input type="radio" 
                            name="status-${reg.id}" 
                            value="Non Applicable" 
                            ${reg.status === 'Non Applicable' ? 'checked' : ''} 
                            onchange="updateStatus('${reg.id}', 'Non Applicable')"> Non Applicable
                    </label>
                    <label>
                        <input type="radio" 
                            name="status-${reg.id}" 
                            value="Documentation" 
                            ${reg.status === 'Documentation' ? 'checked' : ''} 
                            onchange="updateStatus('${reg.id}', 'Documentation')"> Documentation
                    </label>
                </div>
            </div>
            <div class="regulation-content">
                <div class="regulation-text">${reg.text || ''}</div>
                <div class="regulation-id"><i>${reg.id || ''}</i></div>
                ${renderLinks(reg)}
                ${renderRACI(reg)}
                ${renderActions(reg)}
                ${renderJustification(reg)}
                ${renderProofLinks(reg)}
                
                <div class="action-buttons">
                    <button class="button secondary" onclick="editRegulation('${reg.id}')">Éditer</button>
                    <button class="button secondary" onclick="deleteRegulation('${reg.id}')">Supprimer</button>
                </div>
            </div>
        `;
        
        container.appendChild(regulationElement);
    });

    // Configurer l'observateur pour le lazy loading
    setupIntersectionObserver();
}

// Fonction de chargement des données modifiée
async function loadRegulations(reset = false) {
    if (isLoading) return;
    isLoading = true;
    showLoading();

    try {
        if (reset) {
            document.getElementById('wallItems').innerHTML = '';
            lastDoc = null;
        }

        let query = db.collection('regulations')
            .orderBy('createdAt', 'desc')
            .limit(BATCH_SIZE);

        if (lastDoc && !reset) {
            query = query.startAfter(lastDoc);
        }

        const snapshot = await query.get();
        
        if (!snapshot.empty) {
            lastDoc = snapshot.docs[snapshot.docs.length - 1];
            const regulations = snapshot.docs.map(doc => ({
                id: doc.id,
                ...doc.data()
            }));

            renderRegulations(regulations, reset);
            console.log(`${regulations.length} articles chargés`);
        } else {
            if (reset) {
                document.getElementById('wallItems').innerHTML = 
                    '<div class="no-data">Aucune donnée trouvée</div>';
            }
        }

    } catch (error) {
        console.error('Erreur de chargement:', error);
        showNotification('Erreur lors du chargement des données', 'error');
    } finally {
        isLoading = false;
        hideLoading();
    }
}

// Initialisation
document.addEventListener('DOMContentLoaded', () => {
    addStyles();
    loadRegulations(true);
    setupIntersectionObserver();
});

// Fonction de suppression d'une régulation
async function deleteRegulation(regulationId) {
    try {
        if (!confirm('Êtes-vous sûr de vouloir supprimer cette exigence ?')) {
            return;
        }

        showLoading();
        
        // Supprimer le document de Firestore
        await db.collection('regulations').doc(regulationId).delete();
        
        // Supprimer l'élément du DOM
        const element = document.getElementById(`regulation-${regulationId}`);
        if (element) {
            element.remove();
        }
        
        showNotification('Exigence supprimée avec succès', 'success');
        
        // Recharger les données pour mettre à jour le taux de conformité
        await loadRegulations(true);
        
    } catch (error) {
        console.error('Erreur lors de la suppression:', error);
        showNotification('Erreur lors de la suppression', 'error');
    } finally {
        hideLoading();
    }
}

// Fonction pour passer en mode édition
function editRegulation(regulationId) {
    const regulationElement = document.getElementById(`regulation-${regulationId}`);
    if (!regulationElement) return;

    const textElement = regulationElement.querySelector('.regulation-text');
    const originalText = textElement.textContent;

    // Créer le formulaire d'édition
    const editForm = document.createElement('div');
    editForm.className = 'edit-form';
    editForm.innerHTML = `
        <textarea class="input" id="edit-text-${regulationId}">${originalText}</textarea>
        <div class="button-group mt-2">
            <button class="button" onclick="saveRegulationEdit('${regulationId}')">Sauvegarder</button>
            <button class="button secondary" onclick="cancelRegulationEdit('${regulationId}', '${originalText}')">Annuler</button>
        </div>
    `;

    textElement.replaceWith(editForm);
}

// Fonction pour sauvegarder les modifications
async function saveRegulationEdit(regulationId) {
    try {
        showLoading();
        
        const textArea = document.getElementById(`edit-text-${regulationId}`);
        if (!textArea) return;

        const newText = textArea.value.trim();
        if (!newText) {
            showNotification('Le texte ne peut pas être vide', 'error');
            return;
        }

        // Mettre à jour dans Firestore
        await db.collection('regulations').doc(regulationId).update({
            text: newText,
            updatedAt: firebase.firestore.FieldValue.serverTimestamp()
        });

        // Mettre à jour l'affichage
        const editForm = textArea.closest('.edit-form');
        const textElement = document.createElement('div');
        textElement.className = 'regulation-text';
        textElement.textContent = newText;
        editForm.replaceWith(textElement);

        showNotification('Modifications sauvegardées', 'success');

    } catch (error) {
        console.error('Erreur lors de la sauvegarde:', error);
        showNotification('Erreur lors de la sauvegarde', 'error');
    } finally {
        hideLoading();
    }
}

// Fonction pour annuler l'édition
function cancelRegulationEdit(regulationId, originalText) {
    const editForm = document.getElementById(`edit-text-${regulationId}`).closest('.edit-form');
    if (!editForm) return;

    const textElement = document.createElement('div');
    textElement.className = 'regulation-text';
    textElement.textContent = originalText;
    editForm.replaceWith(textElement);
}

// Mise à jour du statut dans Firestore
async function updateStatus(regulationId, status) {
    try {
        await db.collection('regulations').doc(regulationId).update({
            status: status === 'Tous' ? 'all' : status,
            updatedAt: firebase.firestore.FieldValue.serverTimestamp()
        });

        showNotification('Statut mis à jour', 'success');
        
        // Recharger les données pour mettre à jour le taux de conformité
        await loadRegulations(true);

    } catch (error) {
        console.error('Erreur lors de la mise à jour du statut:', error);
        showNotification('Erreur lors de la mise à jour du statut', 'error');
        
        // Réinitialiser les radios en cas d'erreur
        const radios = document.querySelectorAll(`input[name="status-${regulationId}"]`);
        radios.forEach(radio => {
            radio.checked = radio.defaultChecked;
        });
    }
}

// Mise à jour du RACI dans Firestore
async function updateRACI(regulationId, raciType, value) {
    try {
        const updates = {
            [raciType]: value,
            updatedAt: firebase.firestore.FieldValue.serverTimestamp()
        };

        await db.collection('regulations').doc(regulationId).update(updates);
        showNotification('RACI mis à jour', 'success');

    } catch (error) {
        console.error('Erreur lors de la mise à jour du RACI:', error);
        showNotification('Erreur lors de la mise à jour du RACI', 'error');
    }
}

// Styles pour le formulaire d'édition
const editStyles = `
    .edit-form {
        margin: 10px 0;
    }

    .edit-form textarea {
        width: 100%;
        min-height: 100px;
        padding: 8px;
        margin-bottom: 8px;
        border: 1px solid var(--gray-200);
        border-radius: var(--radius-md);
    }

    .edit-form .button-group {
        display: flex;
        gap: 8px;
    }

    .mt-2 {
        margin-top: 8px;
    }
`;

// Ajouter les styles au document
function addEditStyles() {
    const styleElement = document.createElement('style');
    styleElement.textContent = editStyles;
    document.head.appendChild(styleElement);
}

// Initialisation
document.addEventListener('DOMContentLoaded', () => {
    addEditStyles();
});


// Fonction de suppression corrigée
async function deleteRegulation(regulationId) {
    try {
        if (!regulationId) {
            console.error('ID de régulation manquant');
            showNotification('Erreur: ID manquant', 'error');
            return;
        }

        // Confirmation de suppression
        if (!confirm('⚠️ Êtes-vous sûr de vouloir supprimer cette exigence ? Cette action est irréversible.')) {
            return;
        }

        showLoading();
        console.log('Tentative de suppression de:', regulationId);

        // Récupérer une référence au document
        const docRef = db.collection('regulations').doc(regulationId);

        // Vérifier que le document existe
        const doc = await docRef.get();
        if (!doc.exists) {
            throw new Error('Document non trouvé dans Firestore');
        }

        // Supprimer le document
        await docRef.delete();
        console.log('Document supprimé de Firestore:', regulationId);

        // Supprimer l'élément du DOM
        const element = document.getElementById(`regulation-${regulationId}`);
        if (element) {
            element.remove();
            console.log('Élément supprimé du DOM');
        }

        showNotification('Exigence supprimée avec succès', 'success');

        // Recharger les données pour mettre à jour l'affichage
        await loadRegulations(true);

    } catch (error) {
        console.error('Erreur lors de la suppression:', error);
        showNotification(`Erreur lors de la suppression: ${error.message}`, 'error');
    } finally {
        hideLoading();
    }
}

// Fonction utilitaire pour vérifier la connexion Firestore
async function checkFirestoreConnection() {
    try {
        const testDoc = await db.collection('regulations').doc('test').get();
        return true;
    } catch (error) {
        console.error('Erreur de connexion Firestore:', error);
        return false;
    }
}

// Fonction pour afficher une notification plus visible
function showNotification(message, type = 'info') {
    const notification = document.createElement('div');
    notification.className = `notification ${type}`;
    notification.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        padding: 15px 25px;
        background: ${type === 'error' ? '#fee2e2' : '#ecfdf5'};
        color: ${type === 'error' ? '#dc2626' : '#059669'};
        border-radius: 6px;
        box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        z-index: 1000;
        font-weight: 500;
        animation: slideIn 0.3s ease;
    `;
    notification.textContent = message;
    
    document.body.appendChild(notification);
    console.log(`${type.toUpperCase()}: ${message}`);
    
    setTimeout(() => {
        notification.style.animation = 'slideOut 0.3s ease';
        setTimeout(() => notification.remove(), 300);
    }, 5000);
}

// Animation pour les notifications
const notificationStyles = `
    @keyframes slideIn {
        from { transform: translateX(100%); opacity: 0; }
        to { transform: translateX(0); opacity: 1; }
    }
    
    @keyframes slideOut {
        from { transform: translateX(0); opacity: 1; }
        to { transform: translateX(100%); opacity: 0; }
    }
    
    .loading-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(255, 255, 255, 0.8);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 1000;
    }
`;

// Fonction pour montrer l'indicateur de chargement
function showLoading() {
    const overlay = document.createElement('div');
    overlay.className = 'loading-overlay';
    overlay.innerHTML = `
        <div style="
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            display: flex;
            align-items: center;
            gap: 10px;
        ">
            <div class="spinner"></div>
            <span>Traitement en cours...</span>
        </div>
    `;
    document.body.appendChild(overlay);
}

// Fonction pour cacher l'indicateur de chargement
function hideLoading() {
    const overlay = document.querySelector('.loading-overlay');
    if (overlay) {
        overlay.remove();
    }
}

// Ajouter les styles au document
function addStyles() {
    const style = document.createElement('style');
    style.textContent = notificationStyles;
    document.head.appendChild(style);
}

// Initialisation
document.addEventListener('DOMContentLoaded', () => {
    addStyles();
    
    // Vérifier la connexion à Firestore
    checkFirestoreConnection().then(isConnected => {
        if (!isConnected) {
            showNotification('Problème de connexion à la base de données', 'error');
        }
    });
});

// Fonction de suppression corrigée
async function deleteRegulation(regulationId) {
    try {
        if (!regulationId) {
            console.error('ID de régulation manquant');
            showNotification('Erreur: ID manquant', 'error');
            return;
        }

        // Debug log
        console.log('Tentative de suppression du document:', regulationId);

        // Confirmation de suppression
        if (!confirm('⚠️ Êtes-vous sûr de vouloir supprimer cette exigence ? Cette action est irréversible.')) {
            return;
        }

        showLoading();

        // Récupérer tous les documents qui correspondent à l'ID
        const querySnapshot = await db.collection('regulations')
            .where('id', '==', regulationId)
            .get();

        console.log('Documents trouvés:', querySnapshot.size);

        if (querySnapshot.empty) {
            // Essayer de supprimer directement avec l'ID comme identifiant du document
            const docRef = db.collection('regulations').doc(regulationId);
            const doc = await docRef.get();
            
            if (!doc.exists) {
                throw new Error('Document non trouvé dans Firestore');
            }
            
            await docRef.delete();
        } else {
            // Supprimer tous les documents trouvés
            const batch = db.batch();
            querySnapshot.forEach((doc) => {
                console.log('Suppression du document:', doc.id);
                batch.delete(doc.ref);
            });
            await batch.commit();
        }

        // Supprimer l'élément du DOM
        const element = document.getElementById(`regulation-${regulationId}`);
        if (element) {
            element.remove();
            console.log('Élément supprimé du DOM');
        }

        showNotification('Exigence supprimée avec succès', 'success');

        // Recharger les données pour mettre à jour l'affichage
        await loadRegulations(true);

    } catch (error) {
        console.error('Erreur détaillée:', error);
        showNotification(`Erreur lors de la suppression: ${error.message}`, 'error');
    } finally {
        hideLoading();
    }
}

// Fonction modifiée pour ajouter un nouvel article
async function addNewArticle() {
    try {
        const category = document.getElementById('articleCategory').value;
        const reference = document.getElementById('articleReference').value;
        const text = document.getElementById('articleText').value;
        
        if (!category || !reference || !text) {
            showNotification('Tous les champs sont obligatoires', 'error');
            return;
        }

        showLoading();
        
        const parsedRequirements = parseRequirementsFromText(text);
        const batch = db.batch();

        for (const req of parsedRequirements) {
            const articleId = `${reference}-${req.id}`;
            // Utiliser articleId comme ID du document Firestore
            const docRef = db.collection('regulations').doc(articleId);
            
            const articleData = {
                id: articleId, // Garder l'ID dans les données aussi
                category: category,
                text: req.originalText,
                fullPath: req.id,
                parentChain: req.parentChain,
                status: 'all',
                actions: [],
                justification: '',
                proofLinks: [],
                justifications: [],
                responsible: '',
                accountable: '',
                consulted: '',
                informed: '',
                raciCollapsed: false,
                actionsCollapsed: false,
                createdAt: firebase.firestore.FieldValue.serverTimestamp()
            };

            // Ajouter les liens spécifiques selon la catégorie
            if (category === 'Level 1') {
                articleData.rtsLinks = document.getElementById('rtsLink').value
                    .split(',').map(s => s.trim()).filter(Boolean);
                articleData.itsLinks = document.getElementById('itsLink').value
                    .split(',').map(s => s.trim()).filter(Boolean);
            } else if (category === 'RTS' || category === 'ITS') {
                articleData.level1Link = document.getElementById('level1Link').value.trim();
            }

            console.log('Ajout du document:', articleId, articleData);
            batch.set(docRef, articleData);
        }

        await batch.commit();
        console.log('Batch commité avec succès');
        
        showNotification('Articles ajoutés avec succès', 'success');
        resetArticleForm();
        await loadRegulations(true);
        
    } catch (error) {
        console.error('Erreur lors de l\'ajout:', error);
        showNotification('Erreur lors de l\'ajout des articles', 'error');
    } finally {
        hideLoading();
    }
}

// Fonction de chargement modifiée
async function loadRegulations(reset = false) {
    if (isLoading) return;
    isLoading = true;

    try {
        showLoading();

        if (reset) {
            document.getElementById('wallItems').innerHTML = '';
            lastDoc = null;
        }

        let query = db.collection('regulations')
            .orderBy('createdAt', 'desc')
            .limit(BATCH_SIZE);

        if (lastDoc && !reset) {
            query = query.startAfter(lastDoc);
        }

        const snapshot = await query.get();
        console.log('Documents chargés:', snapshot.size);
        
        if (!snapshot.empty) {
            lastDoc = snapshot.docs[snapshot.docs.length - 1];
            const regulations = snapshot.docs.map(doc => ({
                id: doc.id,
                ...doc.data()
            }));
            
            console.log('Données chargées:', regulations);
            renderRegulations(regulations, reset);
        } else {
            if (reset) {
                document.getElementById('wallItems').innerHTML = 
                    '<div class="no-data">Aucune donnée trouvée</div>';
            }
        }

    } catch (error) {
        console.error('Erreur de chargement:', error);
        showNotification('Erreur lors du chargement des données', 'error');
    } finally {
        isLoading = false;
        hideLoading();
    }
}

// Fonction pour générer un ID valide pour Firestore
function generateFirestoreId(reference, reqId) {
    // Remplacer les caractères non valides et les points par des tirets
    const cleanId = `${reference}-${reqId}`.replace(/[.]/g, '-');
    // Assurer un ID valide pour Firestore
    return `reg-${cleanId}`;
}

// Fonction pour ajouter un nouvel article modifiée
async function addNewArticle() {
    try {
        const category = document.getElementById('articleCategory').value;
        const reference = document.getElementById('articleReference').value;
        const text = document.getElementById('articleText').value;
        
        if (!category || !reference || !text) {
            showNotification('Tous les champs sont obligatoires', 'error');
            return;
        }

        showLoading();
        
        const parsedRequirements = parseRequirementsFromText(text);
        const batch = db.batch();

        for (const req of parsedRequirements) {
            // Générer un ID valide pour Firestore
            const displayId = `${reference}-${req.id}`;
            const firestoreId = generateFirestoreId(reference, req.id);
            
            console.log('Création document avec ID:', firestoreId);
            const docRef = db.collection('regulations').doc(firestoreId);
            
            const articleData = {
                id: displayId, // ID pour l'affichage
                firestoreId: firestoreId, // ID Firestore pour référence
                category: category,
                text: req.originalText,
                fullPath: req.id,
                parentChain: req.parentChain,
                status: 'all',
                actions: [],
                justification: '',
                proofLinks: [],
                justifications: [],
                responsible: '',
                accountable: '',
                consulted: '',
                informed: '',
                raciCollapsed: false,
                actionsCollapsed: false,
                createdAt: firebase.firestore.FieldValue.serverTimestamp()
            };

            if (category === 'Level 1') {
                articleData.rtsLinks = document.getElementById('rtsLink').value
                    .split(',').map(s => s.trim()).filter(Boolean);
                articleData.itsLinks = document.getElementById('itsLink').value
                    .split(',').map(s => s.trim()).filter(Boolean);
            } else if (category === 'RTS' || category === 'ITS') {
                articleData.level1Link = document.getElementById('level1Link').value.trim();
            }

            batch.set(docRef, articleData);
        }

        await batch.commit();
        showNotification('Articles ajoutés avec succès', 'success');
        resetArticleForm();
        await loadRegulations(true);
        
    } catch (error) {
        console.error('Erreur lors de l\'ajout:', error);
        showNotification('Erreur lors de l\'ajout des articles', 'error');
    } finally {
        hideLoading();
    }
}

// Fonction de suppression modifiée
async function deleteRegulation(regulationId) {
    try {
        if (!regulationId) {
            console.error('ID de régulation manquant');
            showNotification('Erreur: ID manquant', 'error');
            return;
        }

        console.log('Tentative de suppression:', regulationId);

        if (!confirm('⚠️ Êtes-vous sûr de vouloir supprimer cette exigence ? Cette action est irréversible.')) {
            return;
        }

        showLoading();

        // Rechercher le document par son ID d'affichage
        const querySnapshot = await db.collection('regulations')
            .where('id', '==', regulationId)
            .get();

        if (querySnapshot.empty) {
            throw new Error('Document non trouvé dans Firestore');
        }

        // Supprimer le document
        const docToDelete = querySnapshot.docs[0];
        await docToDelete.ref.delete();
        console.log('Document supprimé:', docToDelete.id);

        // Supprimer l'élément du DOM
        const element = document.getElementById(`regulation-${regulationId}`);
        if (element) {
            element.remove();
        }

        showNotification('Exigence supprimée avec succès', 'success');
        await loadRegulations(true);

    } catch (error) {
        console.error('Erreur détaillée:', error);
        showNotification(`Erreur lors de la suppression: ${error.message}`, 'error');
    } finally {
        hideLoading();
    }
}

// Fonction de rendu modifiée pour utiliser le bon ID
function renderRegulations(regulations, reset = false) {
    const container = document.getElementById('wallItems');
    
    if (reset) {
        container.innerHTML = '';
    }

    regulations.forEach(reg => {
        const regulationElement = document.createElement('div');
        regulationElement.className = 'regulation-item fade-in';
        regulationElement.id = `regulation-${reg.id}`; // Utiliser l'ID d'affichage
        
        regulationElement.innerHTML = `
            <div class="regulation-header">
                <div class="status-controls">
                    <label>
                        <input type="radio" 
                            name="status-${reg.id}" 
                            class="checkbox" 
                            value="Compliant" 
                            ${reg.status === 'Compliant' ? 'checked' : ''} 
                            onchange="updateStatus('${reg.id}', 'Compliant')"> Compliant
                    </label>
                    <label>
                        <input type="radio" 
                            name="status-${reg.id}" 
                            value="Non Applicable" 
                            ${reg.status === 'Non Applicable' ? 'checked' : ''} 
                            onchange="updateStatus('${reg.id}', 'Non Applicable')"> Non Applicable
                    </label>
                    <label>
                        <input type="radio" 
                            name="status-${reg.id}" 
                            value="Documentation" 
                            ${reg.status === 'Documentation' ? 'checked' : ''} 
                            onchange="updateStatus('${reg.id}', 'Documentation')"> Documentation
                    </label>
                </div>
            </div>
            <div class="regulation-content">
                <div class="regulation-text">${reg.text}</div>
                <div class="regulation-id"><i>${reg.id}</i></div>
                ${renderLinks(reg)}
                ${renderRACI(reg)}
                ${renderActions(reg)}
                ${renderJustification(reg)}
                ${renderProofLinks(reg)}
                
                <div class="action-buttons">
                    <button class="button secondary" onclick="editRegulation('${reg.id}')">Éditer</button>
                    <button class="button secondary" onclick="deleteRegulation('${reg.id}')">Supprimer</button>
                </div>
            </div>
        `;
        
        container.appendChild(regulationElement);
    });
}
</script>

</body>
</html>v

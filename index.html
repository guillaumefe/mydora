
<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="DORA Compliance Management System">
    <title>DORA Compliance</title>

    <link rel="preconnect" href="https://cdn.sheetjs.com">
    <script src="https://cdn.sheetjs.com/xlsx-latest/package/dist/shim.min.js"></script>
    <script src="https://cdn.sheetjs.com/xlsx-latest/package/dist/xlsx.full.min.js"></script>


    <style>
    /* ===============================================
       SECTION 1: VARIABLES GLOBALES ET RESET
       =============================================== */
    :root {
        /* Couleurs primaires */
        --primary-50: #eff6ff;
        --primary-100: #dbeafe;
        --primary-200: #bfdbfe;
        --primary-500: #3b82f6;
        --primary-600: #2563eb;
        --primary-700: #1d4ed8;
        
        /* Gris */
        --gray-50: #f9fafb;
        --gray-100: #f3f4f6;
        --gray-200: #e5e7eb;
        --gray-300: #d1d5db;
        --gray-400: #9ca3af;
        --gray-500: #6b7280;
        --gray-600: #4b5563;
        --gray-700: #374151;
        --gray-900: #111827;
        
        /* Succès */
        --success-50: #ecfdf5;
        --success-200: #86efac;
        --success-500: #10b981;
        --success-600: #059669;
        
        /* Warning */
        --warning-50: #fffbeb;
        --warning-200: #fde68a;
        --warning-500: #f59e0b;
        --warning-600: #d97706;
        
        /* Danger */
        --danger-50: #fef2f2;
        --danger-500: #ef4444;
        --danger-600: #dc2626;
        
        /* Espacement */
        --space-1: 0.25rem;
        --space-2: 0.5rem;
        --space-3: 0.75rem;
        --space-4: 1rem;
        --space-6: 1.5rem;
        --space-8: 2rem;
        
        /* Ombres */
        --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
        --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1);
        --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1);
        
        /* Radius */
        --radius-sm: 0.375rem;
        --radius-md: 0.5rem;
        --radius-lg: 0.75rem;
    
        /* Transitions */
        --transition-all: all 0.3s ease;
        --transition-opacity: opacity 0.3s ease;
        --transition-transform: transform 0.3s ease;
    }
    
    /* Reset de base */
    * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
    }
    
    html {
        font-size: 16px;
        height: 100%;
    }
    
    body {
        font-family: system-ui, -apple-system, sans-serif;
        line-height: 1.5;
        background-color: var(--gray-50);
        color: var(--gray-900);
        -webkit-font-smoothing: antialiased;
        min-height: 100%;
    }
    
    /* Container et layout de base */
    .container {
        width: 100%;
        padding: var(--space-4);
        margin: 0 auto;
        max-width: 1200px;
    }
    
    /* ===============================================
       SECTION 2: COMPOSANTS DE BASE
       =============================================== */
    
    /* Cartes */
    .card {
        background-color: white;
        border-radius: var(--radius-lg);
        padding: var(--space-4);
        margin-bottom: var(--space-4);
        border: 1px solid var(--gray-200);
        box-shadow: var(--shadow-sm);
        transition: var(--transition-all);
    }
    
    .card:hover {
        box-shadow: var(--shadow-md);
    }
    
    /* Inputs et champs de formulaire */
    .input {
        width: 100%;
        padding: var(--space-3) var(--space-4);
        border: 1px solid var(--gray-200);
        border-radius: var(--radius-md);
        font-size: 1rem;
        line-height: 1.5;
        color: var(--gray-900);
        transition: var(--transition-all);
    }
    
    .input:focus {
        outline: none;
        border-color: var(--primary-500);
        box-shadow: 0 0 0 2px var(--primary-100);
    }
    
    .input:disabled {
        background-color: var(--gray-100);
        cursor: not-allowed;
    }
    
    textarea.input {
        min-height: 100px;
        resize: vertical;
    }
    
    /* Labels et groupes de formulaire */
    .form-group {
        margin-bottom: var(--space-4);
    }
    
    .form-group label {
        display: block;
        margin-bottom: var(--space-2);
        font-weight: 500;
        color: var(--gray-700);
    }
    
    /* Boutons */
    .button {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        padding: var(--space-2) var(--space-4);
        border-radius: var(--radius-md);
        font-weight: 500;
        font-size: 0.875rem;
        line-height: 1.25rem;
        transition: var(--transition-all);
        cursor: pointer;
        border: none;
        background-color: var(--primary-600);
        color: white;
        gap: var(--space-2);
    }
    
    .button:hover {
        background-color: var(--primary-700);
    }
    
    .button:focus {
        outline: none;
        box-shadow: 0 0 0 2px var(--primary-100);
    }
    
    .button.secondary {
        background-color: white;
        border: 1px solid var(--gray-200);
        color: var(--gray-700);
    }
    
    .button.secondary:hover {
        background-color: var(--gray-50);
        border-color: var(--gray-300);
    }
    
    .button.danger {
        background-color: var(--danger-500);
        color: white;
    }
    
    .button.danger:hover {
        background-color: var(--danger-600);
    }
    
    .button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
    }
    
    /* ===============================================
       SECTION 3: HEADER ET NAVIGATION
       =============================================== */
    
    /* Header principal */
    .header {
        margin-bottom: var(--space-6);
        background-color: white;
        border-radius: var(--radius-lg);
        padding: var(--space-4);
        box-shadow: var(--shadow-sm);
    }
    
    /* Titre et statistiques */
    .title {
        font-size: 1.5rem;
        font-weight: 600;
        color: var(--gray-900);
        margin-bottom: var(--space-2);
    }
    
    .stats-container {
        display: flex;
        flex-wrap: wrap;
        gap: var(--space-4);
        margin-bottom: var(--space-4);
        padding: var(--space-3);
        background-color: var(--primary-50);
        border-radius: var(--radius-md);
    }
    
    .compliance-rate {
        font-size: 1.125rem;
        color: var(--primary-600);
        font-weight: 500;
        display: flex;
        align-items: center;
        gap: var(--space-2);
    }
    
    .compliance-rate-icon {
        font-size: 1.25rem;
    }
    
    .stats-details {
        display: flex;
        flex-wrap: wrap;
        gap: var(--space-4);
        font-size: 0.875rem;
        color: var(--gray-600);
    }
    
    .stat-item {
        display: flex;
        align-items: center;
        gap: var(--space-2);
        padding: var(--space-1) var(--space-2);
        background-color: white;
        border-radius: var(--radius-sm);
        border: 1px solid var(--gray-200);
    }
    
    /* Barre d'import/export */
    .import-export-bar {
        display: flex;
        flex-wrap: wrap;
        gap: var(--space-2);
        background-color: var(--primary-50);
        padding: var(--space-3);
        border-radius: var(--radius-md);
        margin-bottom: var(--space-4);
    }
    
    .import-export-bar .button {
        min-width: 120px;
    }
    
    /* Barre de recherche */
    .search-container {
        margin-bottom: var(--space-4);
    }
    
    .search-wrapper {
        position: relative;
        display: flex;
        align-items: center;
    }
    
    .search-icon {
        position: absolute;
        left: var(--space-3);
        color: var(--gray-400);
        pointer-events: none;
    }
    
    .search-input {
        padding-left: var(--space-8);
        padding-right: var(--space-4);
    }
    
    .search-input:focus + .search-icon {
        color: var(--primary-500);
    }
    
    /* ===============================================
       SECTION 4: FILTRES ET NAVIGATION
       =============================================== */
    
    /* Système d'onglets */
    .tabs {
        display: flex;
        overflow-x: auto;
        gap: var(--space-2);
        margin-bottom: var(--space-4);
        -webkit-overflow-scrolling: touch;
        scrollbar-width: none;
        padding-bottom: var(--space-2);
    }
    
    .tabs::-webkit-scrollbar {
        display: none;
    }
    
    .tab {
        padding: var(--space-2) var(--space-4);
        background-color: var(--gray-100);
        border-radius: var(--radius-md);
        font-size: 0.875rem;
        font-weight: 500;
        color: var(--gray-700);
        white-space: nowrap;
        cursor: pointer;
        transition: var(--transition-all);
        border: 1px solid transparent;
    }
    
    .tab:hover {
        background-color: var(--gray-200);
    }
    
    .tab.active {
        background-color: var(--primary-600);
        color: white;
        border-color: var(--primary-700);
    }
    
    /* Filtres de catégorie */
    .category-filters {
        display: flex;
        flex-wrap: wrap;
        gap: var(--space-2);
        margin-bottom: var(--space-4);
        padding: var(--space-3);
        background-color: var(--gray-50);
        border-radius: var(--radius-md);
        border: 1px solid var(--gray-200);
    }
    
    .category-filter {
        padding: var(--space-2) var(--space-4);
        background-color: white;
        border-radius: var(--radius-md);
        font-size: 0.875rem;
        font-weight: 500;
        color: var(--gray-700);
        cursor: pointer;
        transition: var(--transition-all);
        border: 1px solid var(--gray-200);
    }
    
    .category-filter:hover {
        background-color: var(--gray-50);
        border-color: var(--gray-300);
    }
    
    .category-filter.active {
        background-color: var(--primary-600);
        color: white;
        border-color: var(--primary-700);
    }
    
    /* Options de visibilité */
    .visibility-options {
        display: flex;
        flex-wrap: wrap;
        gap: var(--space-4);
        margin-bottom: var(--space-4);
        padding: var(--space-3);
        background-color: var(--gray-50);
        border-radius: var(--radius-md);
    }
    
    .checkbox-label {
        display: flex;
        align-items: center;
        gap: var(--space-2);
        font-size: 0.875rem;
        color: var(--gray-700);
        cursor: pointer;
    }
    
    .checkbox-label input[type="checkbox"] {
        width: 1rem;
        height: 1rem;
        border-radius: var(--radius-sm);
        border: 1px solid var(--gray-300);
        transition: var(--transition-all);
        cursor: pointer;
    }
    
    .checkbox-label input[type="checkbox"]:checked {
        background-color: var(--primary-600);
        border-color: var(--primary-600);
    }
    
    /* Indicateurs de filtrage actif */
    .active-filters {
        display: flex;
        flex-wrap: wrap;
        gap: var(--space-2);
        margin-bottom: var(--space-4);
    }
    
    .filter-tag {
        display: inline-flex;
        align-items: center;
        gap: var(--space-1);
        padding: var(--space-1) var(--space-2);
        background-color: var(--primary-50);
        color: var(--primary-700);
        border-radius: var(--radius-full);
        font-size: 0.75rem;
        font-weight: 500;
    }
    
    .filter-tag .remove-filter {
        cursor: pointer;
        border-radius: 50%;
        width: 16px;
        height: 16px;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: var(--transition-all);
    }
    
    .filter-tag .remove-filter:hover {
        background-color: var(--primary-100);
    }
    
    /* Media Queries pour la responsivité */
    @media (max-width: 640px) {
        .stats-container {
            flex-direction: column;
            gap: var(--space-2);
        }
    
        .import-export-bar {
            flex-direction: column;
        }
    
        .import-export-bar .button {
            width: 100%;
        }
    
        .tabs {
            padding-bottom: var(--space-3);
        }
    
        .category-filters {
            flex-direction: column;
        }
    
        .visibility-options {
            flex-direction: column;
            gap: var(--space-2);
        }
    }
    
    @media (min-width: 768px) {
        .stats-container {
            justify-content: space-between;
        }
    
        .search-wrapper {
            max-width: 400px;
        }
    }
    
    @media (min-width: 1024px) {
        .header {
            padding: var(--space-6);
        }
    
        .import-export-bar {
            flex-wrap: nowrap;
        }
    }
    
    /* ===============================================
       SECTION 5: REGULATION ITEMS
       =============================================== */
    
    /* Container des régulations */
    .regulations-container {
        display: flex;
        flex-direction: column;
        gap: var(--space-6);
    }
    
    /* Item de régulation */
    .regulation-item {
        background-color: white;
        border-radius: var(--radius-lg);
        border: 1px solid var(--gray-200);
        box-shadow: var(--shadow-sm);
        transition: var(--transition-all);
        overflow: hidden;
        animation: fadeIn 0.3s ease-in;
    }
    
    .regulation-item:hover {
        box-shadow: var(--shadow-md);
    }
    
    /* En-tête de régulation */
    .regulation-header {
        background-color: var(--gray-50);
        padding: var(--space-4);
        border-bottom: 2px solid var(--primary-100);
        display: flex;
        flex-wrap: wrap;
        justify-content: space-between;
        align-items: center;
        gap: var(--space-4);
    }
    
    .regulation-info {
        display: flex;
        flex-wrap: wrap;
        gap: var(--space-3);
        align-items: center;
    }
    
    .regulation-id {
        font-weight: 600;
        color: var(--gray-900);
        font-size: 1.1rem;
    }
    
    .regulation-category {
        display: inline-flex;
        align-items: center;
        padding: var(--space-1) var(--space-2);
        background-color: var(--primary-50);
        color: var(--primary-700);
        border-radius: var(--radius-md);
        font-size: 0.875rem;
        font-weight: 500;
    }
    
    .regulation-controls {
        display: flex;
        gap: var(--space-2);
        align-items: center;
    }
    
    /* Contenu de la régulation */
    .regulation-content {
        padding: var(--space-4);
    }
    
    .regulation-text {
        font-size: 1.1rem;
        color: var(--gray-800);
        padding: var(--space-4);
        background-color: var(--primary-50);
        border-radius: var(--radius-md);
        margin-bottom: var(--space-4);
        border-left: 4px solid var(--primary-500);
        line-height: 1.6;
    }
    
    /* Status de régulation */
    .status-select {
        padding: var(--space-2) var(--space-3);
        border-radius: var(--radius-md);
        border: 1px solid var(--gray-200);
        background-color: white;
        font-size: 0.875rem;
        color: var(--gray-700);
        cursor: pointer;
        transition: var(--transition-all);
    }
    
    .status-select:hover {
        border-color: var(--primary-500);
    }
    
    .status-select:focus {
        outline: none;
        border-color: var(--primary-500);
        box-shadow: 0 0 0 2px var(--primary-100);
    }
    
    /* ===============================================
       SECTION 6: RACI MATRIX
       =============================================== */
    
    /* Container RACI */
    .raci-container {
        background-color: var(--gray-50);
        border-radius: var(--radius-md);
        padding: var(--space-4);
        margin: var(--space-4) 0;
        border: 1px solid var(--gray-200);
        box-shadow: var(--shadow-sm);
    }
    
    .raci-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: var(--space-4);
        padding-bottom: var(--space-2);
        border-bottom: 2px solid var(--primary-200);
    }
    
    .raci-header h4 {
        color: var(--gray-700);
        font-size: 1rem;
        font-weight: 600;
    }
    
    .raci-toggle {
        background: none;
        border: none;
        color: var(--gray-600);
        cursor: pointer;
        padding: var(--space-1);
        transition: var(--transition-all);
    }
    
    .raci-toggle:hover {
        color: var(--gray-900);
    }
    
    /* Grille RACI */
    .raci-grid {
        display: grid;
        gap: var(--space-3);
    }
    
    .raci-row {
        display: grid;
        grid-template-columns: 150px 1fr;
        align-items: center;
        gap: var(--space-3);
        padding: var(--space-2) 0;
    }
    
    .raci-label {
        color: var(--gray-700);
        font-weight: 500;
        font-size: 0.875rem;
        display: flex;
        align-items: center;
        gap: var(--space-2);
    }
    
    .raci-label::before {
        content: '';
        display: inline-block;
        width: 8px;
        height: 8px;
        border-radius: 50%;
    }
    
    .raci-label.responsible::before {
        background-color: var(--primary-500);
    }
    
    .raci-label.accountable::before {
        background-color: var(--warning-500);
    }
    
    .raci-label.consulted::before {
        background-color: var(--success-500);
    }
    
    .raci-label.informed::before {
        background-color: var(--gray-400);
    }
    
    /* Input RACI */
    .raci-input {
        background-color: white;
        border: 1px solid var(--gray-200);
        border-radius: var(--radius-md);
        padding: var(--space-2) var(--space-3);
        font-size: 0.875rem;
        transition: var(--transition-all);
    }
    
    .raci-input:focus {
        outline: none;
        border-color: var(--primary-500);
        box-shadow: 0 0 0 2px var(--primary-100);
    }
    
    /* Tooltips RACI */
    .raci-tooltip {
        position: relative;
        display: inline-block;
    }
    
    .raci-tooltip:hover::after {
        content: attr(data-tooltip);
        position: absolute;
        bottom: 100%;
        left: 50%;
        transform: translateX(-50%);
        padding: var(--space-2) var(--space-3);
        background-color: var(--gray-900);
        color: white;
        font-size: 0.75rem;
        border-radius: var(--radius-sm);
        white-space: nowrap;
        z-index: 10;
    }
    
    /* États RACI */
    .raci-collapsed .raci-grid {
        display: none;
    }
    
    .raci-collapsed .raci-toggle {
        transform: rotate(-90deg);
    }
    
    /* Responsive RACI */
    @media (max-width: 640px) {
        .raci-row {
            grid-template-columns: 1fr;
            gap: var(--space-2);
        }
    
        .raci-label {
            margin-bottom: var(--space-1);
        }
    }
    
    /* Animations RACI */
    .raci-grid {
        transition: var(--transition-all);
        transform-origin: top;
    }
    
    .raci-collapsed .raci-grid {
        transform: scaleY(0);
        height: 0;
    }
    
    .regulation-item.new {
        animation: slideIn 0.3s ease-out;
    }
    
    @keyframes slideIn {
        from {
            opacity: 0;
            transform: translateY(-20px);
        }
        to {
            opacity: 1;
            transform: translateY(0);
        }
    }
    
    /* ===============================================
       SECTION 7: ACTIONS
       =============================================== */
    
    /* Container des actions */
    .actions-container {
        margin-top: var(--space-6);
        background-color: var(--gray-50);
        border-radius: var(--radius-lg);
        padding: var(--space-4);
        border: 1px solid var(--gray-200);
    }
    
    .actions-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: var(--space-4);
        padding-bottom: var(--space-2);
        border-bottom: 2px solid var(--primary-200);
    }
    
    .actions-header h4 {
        color: var(--gray-700);
        font-size: 1rem;
        font-weight: 600;
        display: flex;
        align-items: center;
        gap: var(--space-2);
    }
    
    .actions-count {
        background-color: var(--primary-100);
        color: var(--primary-700);
        padding: 0 var(--space-2);
        border-radius: var(--radius-full);
        font-size: 0.75rem;
    }
    
    /* Liste des actions */
    .actions-list {
        display: flex;
        flex-direction: column;
        gap: var(--space-3);
    }
    
    /* Item d'action */
    .action-item {
        background-color: white;
        border-radius: var(--radius-md);
        border: 1px solid var(--gray-200);
        overflow: hidden;
        transition: var(--transition-all);
    }
    
    .action-item:hover {
        box-shadow: var(--shadow-md);
    }
    
    .action-header {
        background-color: white;
        padding: var(--space-3);
        display: flex;
        justify-content: space-between;
        align-items: center;
        border-bottom: 1px solid var(--gray-200);
        gap: var(--space-3);
    }
    
    .action-text {
        color: var(--gray-900);
        font-weight: 500;
        flex: 1;
    }
    
    .action-controls {
        display: flex;
        align-items: center;
        gap: var(--space-2);
    }
    
    /* Barre de progression */
    .action-progress {
        position: relative;
        width: 100%;
        height: 8px;
        background-color: var(--gray-200);
        border-radius: var(--radius-full);
        overflow: hidden;
    }
    
    .action-progress-bar {
        position: absolute;
        left: 0;
        top: 0;
        height: 100%;
        background-color: var(--primary-500);
        transition: width 0.3s ease;
    }
    
    .action-progress-label {
        font-size: 0.75rem;
        color: var(--gray-600);
        text-align: right;
        margin-top: var(--space-1);
    }
    
    /* Formulaire d'ajout d'action */
    .add-action {
        margin-top: var(--space-4);
        padding-top: var(--space-4);
        border-top: 1px solid var(--gray-200);
    }
    
    .action-input {
        margin-bottom: var(--space-2);
    }
    
    /* ===============================================
       SECTION 8: RISQUES
       =============================================== */
    
    /* Container des risques */
    .risks-container {
        margin-top: var(--space-4);
        padding-top: var(--space-4);
        border-top: 1px solid var(--gray-200);
    }
    
    /* Item de risque */
    .risk-item {
        background-color: white;
        border-radius: var(--radius-md);
        padding: var(--space-3);
        margin-top: var(--space-3);
        border: 1px solid var(--warning-200);
        border-left: 4px solid var(--warning-500);
        transition: var(--transition-all);
    }
    
    .risk-item:hover {
        box-shadow: var(--shadow-sm);
    }
    
    .risk-header {
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        margin-bottom: var(--space-2);
    }
    
    .risk-title {
        font-weight: 500;
        color: var(--gray-900);
    }
    
    .risk-severity {
        display: flex;
        align-items: center;
        gap: var(--space-2);
    }
    
    /* Indicateurs de gravité */
    .severity-indicator {
        display: inline-flex;
        align-items: center;
        padding: var(--space-1) var(--space-2);
        border-radius: var(--radius-sm);
        font-size: 0.75rem;
        font-weight: 500;
    }
    
    .severity-low {
        background-color: var(--success-50);
        color: var(--success-600);
    }
    
    .severity-medium {
        background-color: var(--warning-50);
        color: var(--warning-600);
    }
    
    .severity-high {
        background-color: var(--danger-50);
        color: var(--danger-600);
    }
    
    /* Matrice de risque */
    .risk-matrix {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: var(--space-2);
        margin: var(--space-4) 0;
    }
    
    .matrix-cell {
        aspect-ratio: 1;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: var(--radius-sm);
        font-weight: 500;
        font-size: 0.875rem;
        cursor: pointer;
        transition: var(--transition-all);
    }
    
    /* Actions de remédiation */
    .remediation-actions {
        margin-top: var(--space-3);
        padding-top: var(--space-3);
        border-top: 1px solid var(--gray-200);
    }
    
    .remediation-item {
        display: flex;
        align-items: center;
        gap: var(--space-2);
        padding: var(--space-2);
        background-color: var(--gray-50);
        border-radius: var(--radius-sm);
        margin-top: var(--space-2);
    }
    
    .remediation-status {
        display: flex;
        align-items: center;
        gap: var(--space-1);
        font-size: 0.875rem;
        color: var(--gray-600);
    }
    
    /* Animations et transitions */
    .action-item.new,
    .risk-item.new {
        animation: slideIn 0.3s ease-out;
    }
    
    .risk-item.resolved {
        border-left-color: var(--success-500);
        background-color: var(--success-50);
    }
    
    /* États interactifs */
    .action-item.expanded .action-content {
        max-height: 1000px;
        padding: var(--space-3);
    }
    
    .action-item.collapsed .action-content {
        max-height: 0;
        padding: 0;
    }
    
    /* Responsive design */
    @media (max-width: 640px) {
        .action-header {
            flex-direction: column;
            align-items: stretch;
        }
    
        .action-controls {
            flex-wrap: wrap;
        }
    
        .risk-header {
            flex-direction: column;
            gap: var(--space-2);
        }
    
        .risk-matrix {
            grid-template-columns: repeat(2, 1fr);
        }
    }
    
    @media (min-width: 768px) {
        .action-item {
            display: grid;
            gap: var(--space-4);
        }
    
        .remediation-actions {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: var(--space-3);
        }
    }
    
    /* Loading states */
    .action-item.loading,
    .risk-item.loading {
        position: relative;
        overflow: hidden;
    }
    
    .action-item.loading::after,
    .risk-item.loading::after {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: linear-gradient(
            90deg,
            transparent,
            var(--gray-100),
            transparent
        );
        animation: shimmer 1.5s infinite;
    }
    
    @keyframes shimmer {
        0% { transform: translateX(-100%); }
        100% { transform: translateX(100%); }
    }
    
    /* ===============================================
       SECTION 9: ANIMATIONS ET TRANSITIONS
       =============================================== */
    
    /* Keyframes de base */
    @keyframes fadeIn {
        from {
            opacity: 0;
        }
        to {
            opacity: 1;
        }
    }
    
    @keyframes slideIn {
        from {
            transform: translateY(-20px);
            opacity: 0;
        }
        to {
            transform: translateY(0);
            opacity: 1;
        }
    }
    
    @keyframes slideInRight {
        from {
            transform: translateX(20px);
            opacity: 0;
        }
        to {
            transform: translateX(0);
            opacity: 1;
        }
    }
    
    @keyframes slideInLeft {
        from {
            transform: translateX(-20px);
            opacity: 0;
        }
        to {
            transform: translateX(0);
            opacity: 1;
        }
    }
    
    @keyframes spin {
        to {
            transform: rotate(360deg);
        }
    }
    
    @keyframes shimmer {
        0% {
            background-position: -1000px 0;
        }
        100% {
            background-position: 1000px 0;
        }
    }
    
    @keyframes pulse {
        0% {
            transform: scale(1);
        }
        50% {
            transform: scale(1.05);
        }
        100% {
            transform: scale(1);
        }
    }
    
    /* Classes d'animation */
    .animate-fade-in {
        animation: fadeIn 0.3s ease-in;
    }
    
    .animate-slide-in {
        animation: slideIn 0.3s ease-out;
    }
    
    .animate-slide-in-right {
        animation: slideInRight 0.3s ease-out;
    }
    
    .animate-slide-in-left {
        animation: slideInLeft 0.3s ease-out;
    }
    
    /* ===============================================
       SECTION 10: ÉTATS ET FEEDBACK
       =============================================== */
    
    /* État de chargement */
    .loading-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: rgba(255, 255, 255, 0.8);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 1000;
        opacity: 0;
        visibility: hidden;
        transition: all 0.3s ease;
    }
    
    .loading-overlay.visible {
        opacity: 1;
        visibility: visible;
    }
    
    .loading-spinner {
        width: 40px;
        height: 40px;
        border: 3px solid var(--gray-200);
        border-top-color: var(--primary-500);
        border-radius: 50%;
        animation: spin 1s linear infinite;
    }
    
    /* États de sauvegarde */
    .save-status {
        position: fixed;
        bottom: var(--space-4);
        right: var(--space-4);
        background-color: var(--success-500);
        color: white;
        padding: var(--space-3) var(--space-4);
        border-radius: var(--radius-md);
        font-weight: 500;
        opacity: 0;
        transform: translateY(1rem);
        transition: all 0.3s ease;
        box-shadow: var(--shadow-lg);
        z-index: 1000;
    }
    
    .save-status.visible {
        opacity: 1;
        transform: translateY(0);
    }
    
    /* Notifications */
    .notification {
        position: fixed;
        top: var(--space-4);
        right: var(--space-4);
        padding: var(--space-3) var(--space-4);
        border-radius: var(--radius-md);
        box-shadow: var(--shadow-lg);
        max-width: 400px;
        z-index: 1000;
        animation: slideInRight 0.3s ease-out;
    }
    
    .notification.success {
        background-color: var(--success-50);
        border-left: 4px solid var(--success-500);
        color: var(--success-600);
    }
    
    .notification.error {
        background-color: var(--danger-50);
        border-left: 4px solid var(--danger-500);
        color: var(--danger-600);
    }
    
    .notification.warning {
        background-color: var(--warning-50);
        border-left: 4px solid var(--warning-500);
        color: var(--warning-600);
    }
    
    /* États squelettes */
    .skeleton {
        background: linear-gradient(
            90deg,
            var(--gray-100) 0%,
            var(--gray-200) 50%,
            var(--gray-100) 100%
        );
        background-size: 200% 100%;
        animation: shimmer 1.5s infinite;
    }
    
    /* ===============================================
       SECTION 11: MEDIA QUERIES GLOBALES
       =============================================== */
    
    /* Mobile S */
    @media (max-width: 320px) {
        :root {
            --space-4: 0.75rem;
            --space-6: 1rem;
            --space-8: 1.5rem;
        }
    
        .container {
            padding: var(--space-2);
        }
    
        .button {
            padding: var(--space-1) var(--space-2);
            font-size: 0.8125rem;
        }
    }
    
    /* Mobile */
    @media (max-width: 640px) {
        .regulation-header {
            flex-direction: column;
            gap: var(--space-3);
        }
    
        .regulation-controls {
            width: 100%;
            justify-content: space-between;
        }
    
        .tabs {
            margin: var(--space-2) -var(--space-4);
            padding: 0 var(--space-4);
        }
    
        .notification {
            left: var(--space-4);
            right: var(--space-4);
            max-width: none;
        }
    }
    
    /* Tablette */
    @media (min-width: 641px) and (max-width: 1024px) {
        .regulation-grid {
            grid-template-columns: repeat(2, 1fr);
        }
    
        .raci-grid {
            grid-template-columns: repeat(2, 1fr);
        }
    }
    
    /* Desktop */
    @media (min-width: 1025px) {
        .container {
            padding: var(--space-6);
        }
    
        .regulation-grid {
            grid-template-columns: repeat(3, 1fr);
        }
    
        .stats-container {
            grid-template-columns: repeat(4, 1fr);
        }
    }
    
    /* Grand écran */
    @media (min-width: 1440px) {
        .container {
            max-width: 1400px;
        }
    
        .regulation-grid {
            grid-template-columns: repeat(4, 1fr);
        }
    }
    
    /* ===============================================
       SECTION 12: PRÉFÉRENCES SYSTÈME
       =============================================== */
    
    /* Mode sombre */
    @media (prefers-color-scheme: dark) {
        :root {
            /* Ajustement des couleurs pour le mode sombre */
            --primary-50: #1e293b;
            --primary-100: #334155;
            --gray-50: #0f172a;
            --gray-100: #1e293b;
            --gray-200: #334155;
            --gray-900: #f8fafc;
        }
    
        body {
            background-color: #0f172a;
            color: #f8fafc;
        }
    
        .card,
        .regulation-item {
            background-color: var(--gray-100);
        }
    }
    
    /* Réduction des animations */
    @media (prefers-reduced-motion: reduce) {
        *,
        *::before,
        *::after {
            animation-duration: 0.01ms !important;
            animation-iteration-count: 1 !important;
            transition-duration: 0.01ms !important;
            scroll-behavior: auto !important;
        }
    }
    
    /* Support impression */
    @media print {
        .button,
        .import-export-bar,
        .search-container,
        .tabs,
        .loading-overlay,
        .save-status,
        .notification {
            display: none !important;
        }
    
        .container {
            max-width: none;
            padding: 0;
        }
    
        .regulation-item {
            break-inside: avoid;
            page-break-inside: avoid;
        }
    }
    </style>
    

</head>
<body>
    <div class="container">
        <div class="add-article-container">
            <div class="form-header" onclick="toggleForm()">
                <span>Ajouter un nouvel article</span>
                <span id="form-toggle">▼</span>
            </div>
            <div class="form-content" id="articleForm">
                <div class="form-group">
                    <label for="articleCategory">Catégorie</label>
                    <select id="articleCategory" class="input" onchange="toggleConditionalFields()">
                        <option value="">Sélectionnez une catégorie</option>
                        <option value="Level 1">Level 1</option>
                        <option value="RTS">RTS</option>
                        <option value="ITS">ITS</option>
                    </select>
                </div>

                <div class="form-group">
                    <label for="articleReference">Référence</label>
                    <input type="text" id="articleReference" class="input" placeholder="ex: L1-1, RTS-1, ITS-1">
                </div>

                <div class="form-group">
                    <label for="articleText">Texte de l'article</label>
                    <textarea id="articleText" class="input" rows="4" placeholder="Entrez le texte de l'article"></textarea>
                </div>

                <div class="conditional-fields" id="level1Fields" style="display: none;">
                    <div class="form-group">
                        <label for="rtsLink">RTS associée(s)</label>
                        <input type="text" id="rtsLink" class="input" placeholder="ex: RTS-1, RTS-2">
                    </div>
                    <div class="form-group">
                        <label for="itsLink">ITS associée(s)</label>
                        <input type="text" id="itsLink" class="input" placeholder="ex: ITS-1, ITS-2">
                    </div>
                </div>

                <div class="conditional-fields" id="rtsItsFields" style="display: none;">
                    <div class="form-group">
                        <label for="level1Link">Article Level 1 associé</label>
                        <input type="text" id="level1Link" class="input" placeholder="ex: L1-1">
                    </div>
                </div>

                <div class="form-actions">
                    <button class="button" onclick="addNewArticle()">Ajouter l'article</button>
                    <button class="button secondary" onclick="resetArticleForm()">Réinitialiser</button>
                </div>

                <div class="error-message" id="formError"></div>
            </div>
        </div>

        <div class="card header">
            <h1 class="title">Suivi de Conformité DORA</h1>
            
            <div class="stats-container">
                <div class="compliance-rate">Taux de conformité: <span id="complianceRate">0.0</span>%</div>
                <div class="stats-details">
                    <span class="stat-item">Total: <span id="totalCount">0</span></span>
                    <span class="stat-item">Compliant: <span id="compliantCount">0</span></span>
                    <span class="stat-item">En cours: <span id="inProgressCount">0</span></span>
                </div>
            </div>

            <div class="import-export-bar">
                <button class="button secondary" onclick="exportData()">
                    <span class="icon">📤</span> Exporter
                </button>
                <button class="button secondary" onclick="document.getElementById('importInput').click()">
                    <span class="icon">📥</span> Importer
                </button>
                <input type="file" id="importInput" style="display: none" onchange="importData(event)" accept=".json,.xlsx">
                <button class="button secondary" onclick="resetAll()">
                    <span class="icon">🔄</span> Reset All
                </button>
                <button class="button secondary" onclick="exportProject()">
                    <span class="icon">📊</span> Export Projet
                </button>
            </div>

            <div class="search-container">
                <div class="search-wrapper">
                    <span class="search-icon">🔍</span>
                    <input type="text" 
                           class="input search-input" 
                           id="searchInput" 
                           placeholder="Rechercher un article..."
                           onInput="handleSearchInput(event)">
                </div>
            </div>

            <div class="tabs" id="statusTabs">
                <div class="tab active" data-status="all">Tous</div>
                <div class="tab" data-status="A faire">A faire</div>
                <div class="tab" data-status="En cours">En cours</div>
                <div class="tab" data-status="Compliant">Compliant</div>
                <div class="tab" data-status="Non Applicable">Non Applicable</div>
                <div class="tab" data-status="Documentation">Documentation</div>
                <div class="tab" data-status="Exigences with Risks">Actions avec Risques</div>
            </div>

            <div class="category-filters" id="categoryFilters">
                <span class="category-filter active" data-category="all">Tous</span>
                <span class="category-filter" data-category="Level 1">Level 1</span>
                <span class="category-filter" data-category="RTS">RTS</span>
                <span class="category-filter" data-category="ITS">ITS</span>
            </div>

            <div class="visibility-options">
                <label class="checkbox-label">
                    <input type="checkbox" id="showCompliant" checked onchange="handleVisibilityChange()">
                    Afficher Compliant
                </label>
                <label class="checkbox-label">
                    <input type="checkbox" id="showNonApplicable" checked onchange="handleVisibilityChange()">
                    Afficher Non Applicable
                </label>
                <label class="checkbox-label">
                    <input type="checkbox" id="showDocumentation" checked onchange="handleVisibilityChange()">
                    Afficher Documentation
                </label>
            </div>
        </div>

        <div id="regulationsList" class="regulations-container"></div>

        <template id="regulationTemplate">
            <div class="regulation-item">
                <div class="regulation-header">
                    <div class="regulation-info">
                        <span class="regulation-id"></span>
                        <span class="regulation-category"></span>
                    </div>
                    <div class="regulation-controls">
                        <select class="status-select">
                            <option value="all">À faire</option>
                            <option value="Compliant">Compliant</option>
                            <option value="Non Applicable">Non Applicable</option>
                            <option value="Documentation">Documentation</option>
                        </select>
                        <button class="button danger" onclick="deleteRegulation(this.dataset.id)">Supprimer</button>
                    </div>
                </div>

                <div class="regulation-content">
                    <div class="regulation-text"></div>

                    <div class="raci-container">
                        <div class="raci-header">
                            <h4>Matrice RACI</h4>
                            <button class="raci-toggle">▼</button>
                        </div>
                        <div class="raci-grid">
                            <div class="raci-row">
                                <label class="raci-label responsible">Responsible</label>
                                <input type="text" class="input raci-input" data-raci="responsible">
                            </div>
                            <div class="raci-row">
                                <label class="raci-label accountable">Accountable</label>
                                <input type="text" class="input raci-input" data-raci="accountable">
                            </div>
                            <div class="raci-row">
                                <label class="raci-label consulted">Consulted</label>
                                <input type="text" class="input raci-input" data-raci="consulted">
                            </div>
                            <div class="raci-row">
                                <label class="raci-label informed">Informed</label>
                                <input type="text" class="input raci-input" data-raci="informed">
                            </div>
                        </div>
                    </div>

                    <div class="actions-container">
                        <div class="actions-header">
                            <h4>Actions</h4>
                            <span class="actions-count">0</span>
                        </div>
                        <div class="actions-list"></div>
                        <div class="add-action">
                            <textarea class="input action-input" placeholder="Nouvelle action..."></textarea>
                            <div class="form-actions">
                                <button class="button" onclick="addAction(this.closest('.regulation-item').dataset.id)">
                                    Ajouter une action
                                </button>
                            </div>
                        </div>
                    </div>

                    <div class="links-container">
                        <div class="links-header">
                            <h4>Liens</h4>
                        </div>
                        <div class="level1-links"></div>
                        <div class="rts-links"></div>
                        <div class="its-links"></div>
                    </div>
                </div>
            </div>
        </template>

        <template id="actionTemplate">
            <div class="action-item">
                <div class="action-header">
                    <span class="action-text"></span>
                    <div class="action-controls">
                        <input type="number" 
                               class="input progress-input" 
                               min="0" 
                               max="100" 
                               placeholder="Progression %">
                        <button class="button" onclick="editAction(this.dataset.actionId)">
                            <span class="icon">✏️</span>
                        </button>
                        <button class="button danger" onclick="removeAction(this.dataset.actionId)">
                            <span class="icon">🗑️</span>
                        </button>
                    </div>
                </div>
                <div class="action-content">
                    <div class="action-progress">
                        <div class="progress-bar">
                            <div class="progress-fill"></div>
                        </div>
                        <span class="progress-text">0%</span>
                    </div>
                    <div class="action-details">
                        <div class="action-dates">
                            <span class="start-date"></span>
                            <span class="separator">→</span>
                            <span class="end-date"></span>
                        </div>
                        <div class="action-assignment">
                            <span class="assignee"></span>
                        </div>
                    </div>
                    <div class="risks-list"></div>
                    <button class="button secondary add-risk">
                        <span class="icon">⚠️</span> Ajouter un risque
                    </button>
                </div>
            </div>
        </template>

        <template id="riskTemplate">
            <div class="risk-item">
                <div class="risk-header">
                    <span class="risk-title"></span>
                    <div class="risk-severity"></div>
                </div>
                <div class="risk-content">
                    <div class="risk-description"></div>
                    <div class="risk-metrics">
                        <span class="likelihood"></span>
                        <span class="impact"></span>
                    </div>
                    <div class="remediation-actions"></div>
                </div>
            </div>
        </template>

        <div class="save-status" id="saveStatus">Modifications sauvegardées</div>

        <div class="loading-overlay" id="loadingOverlay">
            <div class="loading-spinner"></div>
            <div class="loading-text">Chargement...</div>
        </div>
    </div>

    
    <script>
        
    // ===============================================
    // CONFIGURATION ET ÉTAT GLOBAL
    // ===============================================
    
    const AppConfig = {
        BATCH_SIZE: 10,
        AUTO_SAVE_DELAY: 1000,
        DEBOUNCE_DELAY: 300,
        API_ENDPOINTS: {
            EXPORT: '/api/export',
            IMPORT: '/api/import'
        },
        STATUSES: {
            TODO: 'A faire',
            IN_PROGRESS: 'En cours',
            COMPLIANT: 'Compliant',
            NOT_APPLICABLE: 'Non Applicable',
            DOCUMENTATION: 'Documentation'
        },
        CATEGORIES: ['Level 1', 'RTS', 'ITS']
    };
    
    const AppState = {
        regulations: [],
        activeFilter: 'all',
        activeStatus: 'all',
        currentPage: 1,
        isLoading: false,
        hasMoreItems: true,
        searchTerm: '',
        worker: null,
        workerUrl: null,
        lastSaveTime: null,
        unsavedChanges: false,
        
        // Statistiques globales
        stats: {
            totalItems: 0,
            visibleItems: 0,
            compliantCount: 0,
            inProgressCount: 0,
            complianceRate: 0
        }
    };
    
    // ===============================================
    // INITIALISATION DE L'APPLICATION
    // ===============================================
    
    function initializeApplication() {
        setupEventListeners();
        initializeState();
        initializeWorker();
        setupAutoSave();
        loadInitialData();
    }
    
    function setupEventListeners() {
        // Écouteurs d'événements de base
        document.addEventListener('DOMContentLoaded', onDOMContentLoaded);
        window.addEventListener('beforeunload', onBeforeUnload);
        
        // Écouteurs des éléments UI
        setupUIEventListeners();
        
        // Écouteurs des formulaires
        setupFormEventListeners();
    }
    
    function initializeState() {
        const savedState = loadFromLocalStorage('appState');
        if (savedState) {
            AppState = { ...AppState, ...savedState };
        }
        updateUIFromState();
    }
    
    function setupAutoSave() {
        setInterval(autoSave, AppConfig.AUTO_SAVE_DELAY);
    }
    
    // ===============================================
    // FONCTIONS D'INITIALISATION SOUS-JACENTES
    // ===============================================
    
    function onDOMContentLoaded() {
        
        try {
            window.uiManager = new UIComponentManager();
        } catch (error) {
            console.error('Erreur lors de l\'initialisation du UIManager:', error);
            // Afficher une erreur utilisateur
            const errorDiv = document.createElement('div');
            errorDiv.className = 'fatal-error';
            errorDiv.textContent = 'Erreur lors du chargement de l\'application';
            document.body.appendChild(errorDiv);
        }
        
        const elements = {
            searchInput: document.getElementById('searchInput'),
            categoryFilters: document.getElementById('categoryFilters'),
            statusTabs: document.getElementById('statusTabs'),
            regulationsList: document.getElementById('regulationsList')
        };
        
        validateRequiredElements(elements);
        initializeUIComponents(elements);
        
    }
    
    function validateRequiredElements(elements) {
        Object.entries(elements).forEach(([key, element]) => {
            if (!element) {
                throw new Error(`Required element missing: ${key}`);
            }
        });
    }
    
    function initializeUIComponents(elements) {
        // Initialisation des composants UI
        initializeSearchInput(elements.searchInput);
        initializeCategoryFilters(elements.categoryFilters);
        initializeStatusTabs(elements.statusTabs);
        initializeRegulationsList(elements.regulationsList);
    }
    
    function setupUIEventListeners() {
        // Recherche
        const searchInput = document.getElementById('searchInput');
        if (searchInput) {
            searchInput.addEventListener('input', debounce(handleSearchInput, AppConfig.DEBOUNCE_DELAY));
        }
    
        // Filtres de catégorie
        const categoryFilters = document.querySelectorAll('.category-filter');
        categoryFilters.forEach(filter => {
            filter.addEventListener('click', handleCategoryFilter);
        });
    
        // Onglets de statut
        const statusTabs = document.querySelectorAll('.tab');
        statusTabs.forEach(tab => {
            tab.addEventListener('click', handleStatusTabClick);
        });
    }
    
    function setupFormEventListeners() {
        // Formulaire d'ajout d'article
        const addArticleForm = document.getElementById('articleForm');
        if (addArticleForm) {
            addArticleForm.addEventListener('submit', handleArticleSubmit);
        }
    
        // Écouteurs pour les champs conditionnels
        const categorySelect = document.getElementById('articleCategory');
        if (categorySelect) {
            categorySelect.addEventListener('change', handleCategoryChange);
        }
    }
    
    // ===============================================
    // FONCTIONS UTILITAIRES
    // ===============================================
    
    function debounce(func, wait) {
        let timeout;
        return function(...args) {
            clearTimeout(timeout);
            timeout = setTimeout(() => func.apply(this, args), wait);
        };
    }
    
    function loadFromLocalStorage(key) {
        try {
            const data = localStorage.getItem(key);
            return data ? JSON.parse(data) : null;
        } catch (error) {
            console.error('Error loading from localStorage:', error);
            return null;
        }
    }
    
    function saveToLocalStorage(key, data) {
        try {
            localStorage.setItem(key, JSON.stringify(data));
            return true;
        } catch (error) {
            console.error('Error saving to localStorage:', error);
            return false;
        }
    }
    
    function updateUIFromState() {
        updateStatistics();
        updateFilters();
        updateRegulationsList();
    }
    
    function autoSave() {
        if (AppState.unsavedChanges) {
            saveToLocalStorage('appState', AppState);
            AppState.unsavedChanges = false;
            AppState.lastSaveTime = Date.now();
            showSaveStatus();
        }
    }
    
    function showSaveStatus() {
        const statusElement = document.getElementById('saveStatus');
        if (statusElement) {
            statusElement.textContent = 'Modifications sauvegardées';
            statusElement.classList.add('visible');
            setTimeout(() => {
                statusElement.classList.remove('visible');
            }, 2000);
        }
    }
    
    function onBeforeUnload(event) {
        if (AppState.unsavedChanges) {
            event.preventDefault();
            return (event.returnValue = 'Vous avez des modifications non sauvegardées. Êtes-vous sûr de vouloir quitter ?');
        }
    }
    
    // ===============================================
    // INITIALISATION DES COMPOSANTS UI
    // ===============================================
    
    function initializeSearchInput(searchInput) {
        searchInput.value = AppState.searchTerm;
        setupSearchAutocomplete(searchInput);
    }
    
    function setupSearchAutocomplete(searchInput) {
        // Configuration de l'autocomplétion
        const searchSuggestions = document.createElement('div');
        searchSuggestions.className = 'search-suggestions';
        searchInput.parentNode.appendChild(searchSuggestions);
    
        searchInput.addEventListener('input', debounce((event) => {
            updateSearchSuggestions(event.target.value, searchSuggestions);
        }, 200));
    }
    
    function updateSearchSuggestions(searchTerm, suggestionsElement) {
        if (!searchTerm) {
            suggestionsElement.innerHTML = '';
            return;
        }
    
        const suggestions = generateSearchSuggestions(searchTerm);
        renderSearchSuggestions(suggestions, suggestionsElement);
    }
    
    function generateSearchSuggestions(searchTerm) {
        return AppState.regulations
            .filter(reg => 
                reg.id.toLowerCase().includes(searchTerm.toLowerCase()) ||
                reg.text.toLowerCase().includes(searchTerm.toLowerCase())
            )
            .slice(0, 5)
            .map(reg => ({
                id: reg.id,
                text: reg.text.substring(0, 50) + '...'
            }));
    }
    
    function renderSearchSuggestions(suggestions, element) {
        element.innerHTML = suggestions
            .map(sugg => `
                <div class="search-suggestion" data-id="${sugg.id}">
                    <strong>${sugg.id}</strong>
                    <span>${sugg.text}</span>
                </div>
            `)
            .join('');
    }
    
    // ===============================================
    // GESTION DES RÉGULATIONS (CRUD)
    // ===============================================
    
    // CREATE
    function addNewArticle() {
        const formData = getArticleFormData();
        
        if (!validateArticleData(formData)) {
            showErrorMessage('Veuillez remplir tous les champs obligatoires');
            return;
        }
    
        const parsedRequirements = parseRequirementsFromText(formData.text);
        const newRegulations = createRegulationsFromRequirements(parsedRequirements, formData);
    
        saveNewRegulations(newRegulations);
        resetArticleForm();
        updateUIAfterAdd(newRegulations);
    }
    
    function getArticleFormData() {
        return {
            category: document.getElementById('articleCategory').value,
            reference: document.getElementById('articleReference').value,
            text: document.getElementById('articleText').value,
            rtsLinks: document.getElementById('rtsLink')?.value || '',
            itsLinks: document.getElementById('itsLink')?.value || '',
            level1Link: document.getElementById('level1Link')?.value || ''
        };
    }
    
    function validateArticleData(data) {
        const required = ['category', 'reference', 'text'];
        const isValid = required.every(field => data[field]?.trim());
        
        const categorySpecificValidation = {
            'Level 1': () => true, // Pas de validation spécifique pour Level 1
            'RTS': () => !!data.level1Link,
            'ITS': () => !!data.level1Link
        };
    
        return isValid && (categorySpecificValidation[data.category]?.() ?? true);
    }
    
    function parseRequirementsFromText(text) {
        const lines = text.split(/\r?\n/)
            .map(line => ({
                text: line.trim(),
                indent: line.search(/\S/),
                isEmpty: !line.trim()
            }))
            .filter(line => !line.isEmpty);
    
        const requirements = [];
        let currentContext = [];
    
        lines.forEach((line, index) => {
            while (currentContext.length > 0 && 
                   currentContext[currentContext.length - 1].indent >= line.indent) {
                currentContext.pop();
            }
            
            currentContext.push(line);
            
            const isLeaf = index === lines.length - 1 || 
                          lines[index + 1].indent <= line.indent;
            
            if (isLeaf) {
                requirements.push({
                    id: generateRequirementId(currentContext),
                    originalText: line.text,
                    parentChain: currentContext.slice(0, -1).map(ctx => ctx.text),
                    indent: line.indent
                });
            }
        });
    
        return requirements;
    }
    
    function generateRequirementId(context) {
        return context.map(ctx => ctx.text.replace(/[^a-zA-Z0-9]/g, '_')).join('.');
    }
    
    function createRegulationsFromRequirements(requirements, formData) {
        return requirements.map(req => createRegulation(req, formData));
    }
    
    function createRegulation(requirement, formData) {
        const baseRegulation = {
            id: `${formData.reference}-${requirement.id}`,
            category: formData.category,
            text: requirement.originalText,
            fullPath: requirement.id,
            parentChain: requirement.parentChain,
            status: AppConfig.STATUSES.TODO,
            createdAt: new Date().toISOString(),
            lastModified: new Date().toISOString(),
            raci: createInitialRACI(),
            actions: [],
            metadata: {
                indent: requirement.indent,
                order: generateOrderIndex()
            }
        };
    
        // Ajout des liens spécifiques à la catégorie
        if (formData.category === 'Level 1') {
            baseRegulation.rtsLinks = parseLinks(formData.rtsLinks);
            baseRegulation.itsLinks = parseLinks(formData.itsLinks);
        } else {
            baseRegulation.level1Link = formData.level1Link;
        }
    
        return baseRegulation;
    }
    
    // READ
    function getRegulationById(id) {
        return AppState.regulations.find(reg => reg.id === id);
    }
    
    function getRegulationsByCategory(category) {
        return category === 'all' 
            ? AppState.regulations 
            : AppState.regulations.filter(reg => reg.category === category);
    }
    
    function getRegulationsByStatus(status) {
        return status === 'all'
            ? AppState.regulations
            : AppState.regulations.filter(reg => reg.status === status);
    }
    
    function getLinkedRegulations(regulation) {
        const linkedIds = [];
        
        if (regulation.category === 'Level 1') {
            linkedIds.push(...regulation.rtsLinks, ...regulation.itsLinks);
        } else {
            linkedIds.push(regulation.level1Link);
        }
    
        return linkedIds
            .map(id => getRegulationById(id))
            .filter(Boolean);
    }
    
    // UPDATE
    function updateRegulation(regulationId, updates) {
        const index = AppState.regulations.findIndex(r => r.id === regulationId);
        if (index === -1) return false;
    
        const updatedRegulation = {
            ...AppState.regulations[index],
            ...updates,
            lastModified: new Date().toISOString()
        };
    
        // Validation spécifique selon le type de mise à jour
        if (!validateRegulationUpdate(updatedRegulation)) {
            showErrorMessage('Mise à jour invalide');
            return false;
        }
    
        AppState.regulations[index] = updatedRegulation;
        AppState.unsavedChanges = true;
    
        // Mise à jour des liens si nécessaire
        if (updates.level1Link || updates.rtsLinks || updates.itsLinks) {
            updateRegulationLinks(updatedRegulation);
        }
    
        notifyRegulationUpdate(updatedRegulation);
        return true;
    }
    
    function validateRegulationUpdate(regulation) {
        const basicValidation = regulation.id && regulation.text && regulation.category;
        if (!basicValidation) return false;
    
        const categoryValidation = {
            'Level 1': reg => Array.isArray(reg.rtsLinks) && Array.isArray(reg.itsLinks),
            'RTS': reg => typeof reg.level1Link === 'string' && reg.level1Link.trim(),
            'ITS': reg => typeof reg.level1Link === 'string' && reg.level1Link.trim()
        };
    
        return categoryValidation[regulation.category]?.(regulation) ?? true;
    }
    
    function updateRegulationLinks(regulation) {
        // Mise à jour des liens bidirectionnels
        if (regulation.category === 'Level 1') {
            updateLevel1Links(regulation);
        } else {
            updateSubordinateLinks(regulation);
        }
    }
    
    // DELETE
    function deleteRegulation(regulationId) {
        if (!confirmDeletion(regulationId)) return false;
    
        const index = AppState.regulations.findIndex(r => r.id === regulationId);
        if (index === -1) return false;
    
        const regulation = AppState.regulations[index];
        
        // Nettoyage des liens avant suppression
        cleanupRegulationLinks(regulation);
        
        // Suppression effective
        AppState.regulations.splice(index, 1);
        AppState.unsavedChanges = true;
    
        notifyRegulationDeletion(regulationId);
        return true;
    }
    
    // FONCTIONS UTILITAIRES
    function createInitialRACI() {
        return {
            responsible: '',
            accountable: '',
            consulted: '',
            informed: ''
        };
    }
    
    function parseLinks(linksString) {
        return linksString
            .split(',')
            .map(link => link.trim())
            .filter(Boolean);
    }
    
    function generateOrderIndex() {
        return AppState.regulations.length + 1;
    }
    
    function cleanupRegulationLinks(regulation) {
        if (regulation.category === 'Level 1') {
            removeLevel1LinksFromSubordinates(regulation);
        } else {
            removeSubordinateLinksFromLevel1(regulation);
        }
    }
    
    function updateLevel1Links(regulation) {
        const oldRegulation = getRegulationById(regulation.id);
        
        // Retirer les anciens liens
        const removedRts = oldRegulation.rtsLinks.filter(link => 
            !regulation.rtsLinks.includes(link));
        const removedIts = oldRegulation.itsLinks.filter(link => 
            !regulation.itsLinks.includes(link));
        
        // Ajouter les nouveaux liens
        const addedRts = regulation.rtsLinks.filter(link => 
            !oldRegulation.rtsLinks.includes(link));
        const addedIts = regulation.itsLinks.filter(link => 
            !oldRegulation.itsLinks.includes(link));
    
        // Mettre à jour les régulations liées
        updateLinkedRegulations(removedRts, addedRts, removedIts, addedIts, regulation.id);
    }
    
    function notifyRegulationUpdate(regulation) {
        if (AppState.worker) {
            AppState.worker.postMessage({
                type: 'REGULATION_UPDATE',
                data: { regulation }
            });
        }
        
        dispatchEvent(new CustomEvent('regulationUpdate', { detail: regulation }));
    }
    
    function notifyRegulationDeletion(regulationId) {
        if (AppState.worker) {
            AppState.worker.postMessage({
                type: 'REGULATION_DELETE',
                data: { regulationId }
            });
        }
        
        dispatchEvent(new CustomEvent('regulationDelete', { detail: regulationId }));
    }
    
    function confirmDeletion(regulationId) {
        const regulation = getRegulationById(regulationId);
        if (!regulation) return true;
    
        const hasLinks = regulation.category === 'Level 1' 
            ? (regulation.rtsLinks.length > 0 || regulation.itsLinks.length > 0)
            : !!regulation.level1Link;
    
        if (hasLinks) {
            return confirm(`Cette régulation a des liens avec d'autres articles. Êtes-vous sûr de vouloir la supprimer ?`);
        }
    
        return confirm(`Êtes-vous sûr de vouloir supprimer cette régulation ?`);
    }
    
    // ===============================================
    // GESTION DES ACTIONS
    // ===============================================
    
    // Création d'action
    function addAction(regulationId, actionData) {
        const regulation = getRegulationById(regulationId);
        if (!regulation) {
            showErrorMessage("Régulation non trouvée");
            return null;
        }
    
        const newAction = createAction(actionData);
        if (!validateAction(newAction)) {
            showErrorMessage("Action invalide");
            return null;
        }
    
        regulation.actions.push(newAction);
        updateRegulationStatus(regulation);
        notifyActionCreation(regulation, newAction);
        
        return newAction;
    }
    
    function createAction(data) {
        return {
            id: generateActionId(),
            text: data.text,
            description: data.description || '',
            percentage: 0,
            status: 'pending',
            priority: data.priority || 'medium',
            assignedTo: data.assignedTo || '',
            createdAt: new Date().toISOString(),
            lastModified: new Date().toISOString(),
            startDate: data.startDate || null,
            endDate: data.endDate || null,
            estimatedDuration: data.estimatedDuration || null,
            risks: [],
            comments: [],
            attachments: [],
            history: [{
                type: 'creation',
                date: new Date().toISOString(),
                details: 'Action créée'
            }],
            raci: createActionRACI(data.raci)
        };
    }
    
    // Mise à jour d'action
    function updateAction(regulationId, actionId, updates) {
        const regulation = getRegulationById(regulationId);
        const actionIndex = regulation?.actions.findIndex(a => a.id === actionId);
        
        if (actionIndex === -1) {
            showErrorMessage("Action non trouvée");
            return false;
        }
    
        const currentAction = regulation.actions[actionIndex];
        const updatedAction = {
            ...currentAction,
            ...updates,
            lastModified: new Date().toISOString()
        };
    
        // Validation de la mise à jour
        if (!validateActionUpdate(currentAction, updatedAction)) {
            showErrorMessage("Mise à jour invalide");
            return false;
        }
    
        // Création d'un historique des modifications
        const changes = trackActionChanges(currentAction, updatedAction);
        if (changes.length > 0) {
            updatedAction.history.push({
                type: 'update',
                date: new Date().toISOString(),
                changes
            });
        }
    
        regulation.actions[actionIndex] = updatedAction;
        updateRegulationStatus(regulation);
        notifyActionUpdate(regulation, updatedAction);
        
        return true;
    }
    
    // Suppression d'action
    function deleteAction(regulationId, actionId) {
        const regulation = getRegulationById(regulationId);
        if (!regulation) return false;
    
        const actionIndex = regulation.actions.findIndex(a => a.id === actionId);
        if (actionIndex === -1) return false;
    
        const action = regulation.actions[actionIndex];
        
        // Vérification des dépendances
        if (action.risks.length > 0) {
            const confirmed = confirm(
                `Cette action contient ${action.risks.length} risque(s). Êtes-vous sûr de vouloir la supprimer ?`
            );
            if (!confirmed) return false;
        }
    
        regulation.actions.splice(actionIndex, 1);
        updateRegulationStatus(regulation);
        notifyActionDeletion(regulation, actionId);
        
        return true;
    }
    
    // ===============================================
    // GESTION DES RISQUES
    // ===============================================
    
    // Création de risque
    function addRisk(regulationId, actionId, riskData) {
        const action = findAction(regulationId, actionId);
        if (!action) {
            showErrorMessage("Action non trouvée");
            return null;
        }
    
        const newRisk = createRisk(riskData);
        if (!validateRisk(newRisk)) {
            showErrorMessage("Risque invalide");
            return null;
        }
    
        action.risks.push(newRisk);
        updateRiskMetrics(action);
        notifyRiskCreation(regulationId, actionId, newRisk);
        
        return newRisk;
    }
    
    function createRisk(data) {
        return {
            id: generateRiskId(),
            description: data.description,
            category: data.category || 'operational',
            severity: validateSeverity(data.severity) ? data.severity : 'medium',
            likelihood: validateLikelihood(data.likelihood) ? data.likelihood : 'medium',
            impact: calculateRiskImpact(data.severity, data.likelihood),
            status: 'identified',
            createdAt: new Date().toISOString(),
            lastModified: new Date().toISOString(),
            remediationPlan: data.remediationPlan || null,
            remediationStatus: 'pending',
            remediationDeadline: data.remediationDeadline || null,
            assignedTo: data.assignedTo || null,
            reviewDate: data.reviewDate || null,
            history: [{
                type: 'creation',
                date: new Date().toISOString(),
                details: 'Risque identifié'
            }],
            tags: data.tags || [],
            attachments: [],
            comments: []
        };
    }
    
    // Mise à jour de risque
    function updateRisk(regulationId, actionId, riskId, updates) {
        const action = findAction(regulationId, actionId);
        if (!action) return false;
    
        const riskIndex = action.risks.findIndex(r => r.id === riskId);
        if (riskIndex === -1) return false;
    
        const currentRisk = action.risks[riskIndex];
        const updatedRisk = {
            ...currentRisk,
            ...updates,
            lastModified: new Date().toISOString()
        };
    
        // Recalcul de l'impact si nécessaire
        if (updates.severity || updates.likelihood) {
            updatedRisk.impact = calculateRiskImpact(
                updatedRisk.severity,
                updatedRisk.likelihood
            );
        }
    
        // Validation de la mise à jour
        if (!validateRiskUpdate(currentRisk, updatedRisk)) {
            showErrorMessage("Mise à jour du risque invalide");
            return false;
        }
    
        // Suivi des modifications
        const changes = trackRiskChanges(currentRisk, updatedRisk);
        if (changes.length > 0) {
            updatedRisk.history.push({
                type: 'update',
                date: new Date().toISOString(),
                changes
            });
        }
    
        action.risks[riskIndex] = updatedRisk;
        updateRiskMetrics(action);
        notifyRiskUpdate(regulationId, actionId, updatedRisk);
        
        return true;
    }
    
    // ===============================================
    // FONCTIONS UTILITAIRES
    // ===============================================
    
    // Utilitaires d'action
    function validateAction(action) {
        return (
            action.text?.trim() &&
            typeof action.percentage === 'number' &&
            action.percentage >= 0 &&
            action.percentage <= 100
        );
    }
    
    function validateActionUpdate(currentAction, updatedAction) {
        // Validation de base
        if (!validateAction(updatedAction)) return false;
    
        // Validation des dates
        if (updatedAction.startDate && updatedAction.endDate) {
            if (new Date(updatedAction.startDate) > new Date(updatedAction.endDate)) {
                return false;
            }
        }
    
        // Validation du pourcentage
        if (updatedAction.percentage < currentAction.percentage) {
            return confirm("Le pourcentage d'avancement va diminuer. Continuer ?");
        }
    
        return true;
    }
    
    function trackActionChanges(oldAction, newAction) {
        const changes = [];
        const trackableFields = [
            'text', 'percentage', 'status', 'priority', 
            'assignedTo', 'startDate', 'endDate'
        ];
    
        trackableFields.forEach(field => {
            if (oldAction[field] !== newAction[field]) {
                changes.push({
                    field,
                    oldValue: oldAction[field],
                    newValue: newAction[field]
                });
            }
        });
    
        return changes;
    }
    
    // Utilitaires de risque
    function validateRisk(risk) {
        return (
            risk.description?.trim() &&
            validateSeverity(risk.severity) &&
            validateLikelihood(risk.likelihood)
        );
    }
    
    function validateSeverity(severity) {
        return ['low', 'medium', 'high', 'critical'].includes(severity);
    }
    
    function validateLikelihood(likelihood) {
        return ['rare', 'unlikely', 'possible', 'likely', 'almost-certain'].includes(likelihood);
    }
    
    function calculateRiskImpact(severity, likelihood) {
        const severityScores = {
            low: 1,
            medium: 2,
            high: 3,
            critical: 4
        };
    
        const likelihoodScores = {
            rare: 1,
            unlikely: 2,
            possible: 3,
            likely: 4,
            'almost-certain': 5
        };
    
        const impactScore = severityScores[severity] * likelihoodScores[likelihood];
        
        if (impactScore <= 4) return 'low';
        if (impactScore <= 8) return 'medium';
        if (impactScore <= 12) return 'high';
        return 'critical';
    }
    
    // Utilitaires de notification
    function notifyActionCreation(regulation, action) {
        dispatchEvent(new CustomEvent('actionCreated', {
            detail: { regulationId: regulation.id, action }
        }));
        
        AppState.unsavedChanges = true;
    }
    
    function notifyActionUpdate(regulation, action) {
        dispatchEvent(new CustomEvent('actionUpdated', {
            detail: { regulationId: regulation.id, action }
        }));
        
        AppState.unsavedChanges = true;
    }
    
    function notifyRiskCreation(regulationId, actionId, risk) {
        dispatchEvent(new CustomEvent('riskCreated', {
            detail: { regulationId, actionId, risk }
        }));
        
        AppState.unsavedChanges = true;
    }
    
    // Utilitaires de génération d'ID
    function generateActionId() {
        return `action_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }
    
    function generateRiskId() {
        return `risk_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }
    
    // Utilitaires de recherche
    function findAction(regulationId, actionId) {
        const regulation = getRegulationById(regulationId);
        return regulation?.actions.find(a => a.id === actionId);
    }
    
    function updateRiskMetrics(action) {
        action.riskLevel = calculateActionRiskLevel(action.risks);
        action.highestRisk = findHighestRisk(action.risks);
    }
    
    function calculateActionRiskLevel(risks) {
        if (!risks.length) return 'none';
        
        const impactScores = risks.map(risk => {
            const scores = { low: 1, medium: 2, high: 3, critical: 4 };
            return scores[risk.impact];
        });
    
        const maxScore = Math.max(...impactScores);
        const scoreMap = { 1: 'low', 2: 'medium', 3: 'high', 4: 'critical' };
        
        return scoreMap[maxScore];
    }
    
    // ===============================================
    // CONFIGURATION DU WORKER
    // ===============================================
    
    const workerScript = `
        // État interne du worker
        let regulations = [];
        let filteredRegs = [];
        const BATCH_SIZE = 10;
        let currentFilters = {
            searchTerm: '',
            activeFilter: 'all',
            activeStatus: 'all'
        };
    
        // Gestionnaire principal des messages
        self.onmessage = function(e) {
            const { type, data } = e.data;
            
            switch (type) {
                case 'INIT_DATA':
                    handleInitData(data);
                    break;
                case 'FILTER_UPDATE':
                    handleFilterUpdate(data);
                    break;
                case 'REQUEST_BATCH':
                    handleBatchRequest(data);
                    break;
                case 'REGULATION_UPDATE':
                    handleRegulationUpdate(data);
                    break;
                case 'FULL_REINDEX':
                    handleFullReindex(data);
                    break;
                case 'COMPUTE_METRICS':
                    handleComputeMetrics();
                break;
        }
    };

    // Gestionnaires de messages spécifiques
    function handleInitData(data) {
        regulations = data.regulations;
        createSearchIndex();
        applyCurrentFilters();
    }

    function handleFilterUpdate(data) {
        currentFilters = { ...currentFilters, ...data };
        applyCurrentFilters();
    }

    function handleBatchRequest(data) {
        sendBatch(data.startIndex);
    }

    function handleRegulationUpdate(data) {
        updateRegulationInIndex(data.regulation);
        applyCurrentFilters();
    }

    // Logique de filtrage et recherche
    function applyCurrentFilters() {
        filteredRegs = regulations.filter(reg => {
            // Filtrage par recherche
            if (currentFilters.searchTerm) {
                const searchMatches = performSearch(reg, currentFilters.searchTerm);
                if (!searchMatches) return false;
            }

            // Filtrage par catégorie
            if (currentFilters.activeFilter !== 'all' && 
                reg.category !== currentFilters.activeFilter) {
                return false;
            }

            // Filtrage par statut
            if (currentFilters.activeStatus !== 'all') {
                switch(currentFilters.activeStatus) {
                    case 'A faire':
                        return !hasProgress(reg);
                    case 'En cours':
                        return hasPartialProgress(reg);
                    case 'Compliant':
                        return isCompliant(reg);
                    case 'Non Applicable':
                        return reg.status === 'Non Applicable';
                    case 'Exigences with Risks':
                        return hasRisks(reg);
                    default:
                        return reg.status === currentFilters.activeStatus;
                }
            }

            return true;
        });

        // Trier les résultats
        sortFilteredResults();
        
        // Envoyer les métadonnées mises à jour
        sendMetadataUpdate();
        
        // Envoyer le premier lot
        sendBatch(0);
    }

    // Système d'indexation pour la recherche
    let searchIndex = null;

    function createSearchIndex() {
        searchIndex = regulations.map(reg => ({
            id: reg.id,
            searchableContent: generateSearchableContent(reg),
            keywords: extractKeywords(reg)
        }));
    }

    function generateSearchableContent(reg) {
        return [
            reg.id,
            reg.text,
            reg.category,
            reg.status,
            ...reg.actions.map(a => a.text),
            reg.responsible,
            reg.accountable,
            reg.consulted,
            reg.informed,
            ...(reg.justifications || []).map(j => j.text),
            ...(reg.proofLinks || [])
        ].filter(Boolean).join(' ').toLowerCase();
    }

    function extractKeywords(reg) {
        const keywords = new Set();
        // Extraire les mots clés importants du texte
        const textWords = reg.text.toLowerCase()
            .match(/\\b\\w+\\b/g) || [];
        
        // Ajouter les mots clés spécifiques
        textWords.forEach(word => {
            if (word.length > 3) keywords.add(word);
        });

        // Ajouter les identifiants et références
        keywords.add(reg.id.toLowerCase());
        reg.category.toLowerCase().split(/\\s+/).forEach(word => keywords.add(word));

        return Array.from(keywords);
    }

    function performSearch(reg, searchTerm) {
        const indexEntry = searchIndex.find(entry => entry.id === reg.id);
        if (!indexEntry) return false;

        const terms = searchTerm.toLowerCase().split(/\\s+/);
        return terms.every(term => {
            // Recherche exacte
            if (indexEntry.searchableContent.includes(term)) return true;
            
            // Recherche par mot-clé
            return indexEntry.keywords.some(keyword => 
                keyword.includes(term) || term.includes(keyword)
            );
        });
    }

    // Fonctions de tri et pagination
    function sortFilteredResults() {
        filteredRegs.sort((a, b) => {
            // Trier d'abord par catégorie
            if (a.category !== b.category) {
                return a.category.localeCompare(b.category);
            }
            
            // Puis par statut de complétion
            const completionA = calculateCompletionRate(a);
            const completionB = calculateCompletionRate(b);
            if (completionA !== completionB) {
                return completionB - completionA;
            }
            
            // Enfin par ID
            return a.id.localeCompare(b.id);
        });
    }

    function sendBatch(startIndex) {
        const batch = filteredRegs.slice(startIndex, startIndex + BATCH_SIZE);
        const hasMore = startIndex + BATCH_SIZE < filteredRegs.length;

        self.postMessage({
            type: 'BATCH_READY',
            data: {
                items: batch,
                total: filteredRegs.length,
                hasMore: hasMore,
                startIndex: startIndex
            }
        });
    }

    // Métriques et statistiques
    function calculateMetrics() {
        const metrics = {
            total: regulations.length,
            compliant: 0,
            inProgress: 0,
            notStarted: 0,
            withRisks: 0,
            risksByLevel: {
                low: 0,
                medium: 0,
                high: 0,
                critical: 0
            },
            completionRate: 0,
            averageProgress: 0,
            categoryBreakdown: {}
        };

        regulations.forEach(reg => {
            updateMetricsForRegulation(reg, metrics);
        });

        // Calcul des moyennes finales
        finalizeMetrics(metrics);

        return metrics;
    }

    function sendMetadataUpdate() {
        const metrics = calculateMetrics();
        
        self.postMessage({
            type: 'METADATA_UPDATE',
            data: {
                total: filteredRegs.length,
                metrics: metrics,
                lastUpdated: new Date().toISOString()
            }
        });
    }

    // Fonctions utilitaires
    function hasProgress(reg) {
        return reg.actions.some(action => action.percentage > 0);
    }

    function hasPartialProgress(reg) {
        const total = reg.actions.reduce((sum, action) => sum + action.percentage, 0);
        const average = reg.actions.length ? total / reg.actions.length : 0;
        return average > 0 && average < 100;
    }

    function isCompliant(reg) {
        return reg.status === 'Compliant' || 
               (reg.actions.length > 0 && 
                reg.actions.every(action => action.percentage === 100));
    }

    function hasRisks(reg) {
        return reg.actions.some(action => action.risks && action.risks.length > 0);
    }

    function calculateCompletionRate(reg) {
        if (!reg.actions.length) return 0;
        const total = reg.actions.reduce((sum, action) => sum + action.percentage, 0);
        return total / reg.actions.length;
    }

    function updateMetricsForRegulation(reg, metrics) {
        // Mise à jour des compteurs de base
        const completionRate = calculateCompletionRate(reg);
        
        if (isCompliant(reg)) {
            metrics.compliant++;
        } else if (hasProgress(reg)) {
            metrics.inProgress++;
        } else {
            metrics.notStarted++;
        }

        // Analyse des risques
        let hasAnyRisks = false;
        reg.actions.forEach(action => {
            if (action.risks && action.risks.length) {
                hasAnyRisks = true;
                action.risks.forEach(risk => {
                    metrics.risksByLevel[risk.impact]++;
                });
            }
        });
        if (hasAnyRisks) metrics.withRisks++;

        // Mise à jour des statistiques par catégorie
        metrics.categoryBreakdown[reg.category] = 
            (metrics.categoryBreakdown[reg.category] || 0) + 1;

        // Accumulation pour moyennes
        metrics.completionRate += completionRate;
        metrics.averageProgress += calculateCompletionRate(reg);
    }

    function finalizeMetrics(metrics) {
        metrics.completionRate = Math.round(
            (metrics.completionRate / regulations.length) * 100
        ) / 100;
        
        metrics.averageProgress = Math.round(
            (metrics.averageProgress / regulations.length) * 100
        ) / 100;
    }
`;

// ===============================================
// INITIALISATION ET GESTION DU WORKER
// ===============================================

function initializeWorker() {
    try {
        const blob = new Blob([workerScript], { type: 'application/javascript' });
        const workerUrl = URL.createObjectURL(blob);
        const worker = new Worker(workerUrl);

        worker.onmessage = handleWorkerMessage;
        worker.onerror = handleWorkerError;

        AppState.worker = worker;
        AppState.workerUrl = workerUrl;

        // Initialisation du worker avec les données actuelles
        sendInitialDataToWorker();

        return true;
    } catch (error) {
        console.error('Erreur d\'initialisation du worker:', error);
        fallbackToSynchronousMode();
        return false;
    }
}

function handleWorkerMessage(e) {
    const { type, data } = e.data;

    switch (type) {
        case 'BATCH_READY':
            renderBatch(data);
            break;
        case 'METADATA_UPDATE':
            updateUIMetrics(data);
            break;
        case 'ERROR':
            handleWorkerError(data);
            break;
    }
}

function handleWorkerError(error) {
    console.error('Erreur du worker:', error);
    showErrorNotification('Une erreur est survenue dans le traitement des données');
    fallbackToSynchronousMode();
}

// ===============================================
// COMMUNICATION AVEC LE WORKER
// ===============================================

function sendInitialDataToWorker() {
    if (!AppState.worker) return;
    
    AppState.worker.postMessage({
        type: 'INIT_DATA',
        data: { regulations: AppState.regulations }
    });
}

function requestFilterUpdate(filters) {
    if (!AppState.worker) return;
    
    AppState.worker.postMessage({
        type: 'FILTER_UPDATE',
        data: filters
    });
}

function requestBatch(startIndex) {
    if (!AppState.worker) return;
    
    AppState.worker.postMessage({
        type: 'REQUEST_BATCH',
        data: { startIndex }
    });
}

// ===============================================
// GESTION DU MODE SYNCHRONE (FALLBACK)
// ===============================================

function fallbackToSynchronousMode() {
    AppState.workerEnabled = false;
    
    // Implémenter les fonctions de filtrage et tri en synchrone
    const synchronousFilter = createSynchronousFilter();
    const synchronousSort = createSynchronousSort();
    
    // Remplacer les fonctions asynchrones par leurs équivalents synchrones
    AppState.filterFunction = synchronousFilter;
    AppState.sortFunction = synchronousSort;
    
    // Mettre à jour l'interface utilisateur
    updateUIForSynchronousMode();
}

function createSynchronousFilter() {
    // Version synchrone de la fonction de filtrage
    return function(regulations, filters) {
        return regulations.filter(reg => {
            // [Logique de filtrage similaire à celle du worker]
            return true; // Simplifié pour l'exemple
        });
    };
}

function createSynchronousSort() {
    // Version synchrone de la fonction de tri
    return function(regulations) {
        return [...regulations].sort((a, b) => {
            // [Logique de tri similaire à celle du worker]
            return 0; // Simplifié pour l'exemple
        });
    };
}

// ===============================================
// NETTOYAGE
// ===============================================

function cleanupWorker() {
    if (AppState.worker) {
        AppState.worker.terminate();
        AppState.worker = null;
    }
    
    if (AppState.workerUrl) {
        URL.revokeObjectURL(AppState.workerUrl);
        AppState.workerUrl = null;
    }
}

// Ajout d'un écouteur pour le nettoyage
window.addEventListener('beforeunload', cleanupWorker);

// ===============================================
// EXPORT DES DONNÉES
// ===============================================

// Export Excel complet
function exportProject() {
    try {
        const wb = XLSX.utils.book_new();
        
        // Création des différentes feuilles
        const regulationsSheet = createRegulationsSheet();
        const actionsSheet = createActionsSheet();
        const risksSheet = createRisksSheet();
        const statisticsSheet = createStatisticsSheet();
        const raciSheet = createRaciSheet();
        const timelineSheet = createTimelineSheet();

        // Ajout des feuilles au workbook avec styles
        addSheetWithStyles(wb, regulationsSheet, 'Réglementations');
        addSheetWithStyles(wb, actionsSheet, 'Actions');
        addSheetWithStyles(wb, risksSheet, 'Risques');
        addSheetWithStyles(wb, statisticsSheet, 'Statistiques');
        addSheetWithStyles(wb, raciSheet, 'RACI');
        addSheetWithStyles(wb, timelineSheet, 'Timeline');

        // Export du fichier
        const fileName = `DORA_Compliance_${formatDate(new Date())}.xlsx`;
        XLSX.writeFile(wb, fileName);
        
        showSuccessMessage('Export réussi');
        
        // Log de l'export
        logExportActivity(fileName);
    } catch (error) {
        console.error('Erreur lors de l\'export:', error);
        showErrorMessage('Erreur lors de l\'export du projet');
    }
}

// Création des feuilles spécifiques
function createRegulationsSheet() {
    const headers = [
        'ID',
        'Catégorie',
        'Status',
        'Texte',
        'Progression',
        'Nombre d\'actions',
        'Risques',
        'Dernière modification',
        'RACI - Responsible',
        'RACI - Accountable',
        'RACI - Consulted',
        'RACI - Informed',
        'Liens Level 1',
        'Liens RTS',
        'Liens ITS'
    ];

    const data = AppState.regulations.map(reg => {
        const progress = calculateRegulationProgress(reg);
        const risks = countRegulationRisks(reg);

        return [
            reg.id,
            reg.category,
            reg.status,
            reg.text,
            `${progress}%`,
            reg.actions.length,
            risks,
            formatDate(reg.lastModified),
            reg.raci.responsible,
            reg.raci.accountable,
            reg.raci.consulted,
            reg.raci.informed,
            reg.level1Link || '',
            (reg.rtsLinks || []).join(', '),
            (reg.itsLinks || []).join(', ')
        ];
    });

    return { headers, data };
}

function createActionsSheet() {
    const headers = [
        'ID Régulation',
        'ID Action',
        'Description',
        'Progression',
        'Responsable',
        'Date début',
        'Date fin',
        'Status',
        'Priorité',
        'Nombre de risques',
        'Dernière modification'
    ];

    const data = AppState.regulations.flatMap(reg =>
        reg.actions.map(action => [
            reg.id,
            action.id,
            action.text,
            `${action.percentage}%`,
            action.assignedTo,
            formatDate(action.startDate),
            formatDate(action.endDate),
            action.status,
            action.priority,
            action.risks?.length || 0,
            formatDate(action.lastModified)
        ])
    );

    return { headers, data };
}

// Export JSON
function exportToJson() {
    try {
        const exportData = prepareDataForExport();
        const dataStr = JSON.stringify(exportData, null, 2);
        const dataUri = `data:application/json;charset=utf-8,${encodeURIComponent(dataStr)}`;
        
        downloadFile(dataUri, `DORA_Compliance_${formatDate(new Date())}.json`);
        showSuccessMessage('Export JSON réussi');
    } catch (error) {
        console.error('Erreur lors de l\'export JSON:', error);
        showErrorMessage('Erreur lors de l\'export JSON');
    }
}

// ===============================================
// IMPORT DES DONNÉES
// ===============================================

function importData(event) {
    const file = event.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    
    reader.onload = async function(e) {
        try {
            // Détection du type de fichier
            const fileType = detectFileType(file.name);
            
            switch(fileType) {
                case 'json':
                    await handleJsonImport(e.target.result);
                    break;
                case 'xlsx':
                    await handleExcelImport(e.target.result);
                    break;
                default:
                    throw new Error('Format de fichier non supporté');
            }

            showSuccessMessage('Import réussi');
            reloadApplication();
        } catch (error) {
            console.error('Erreur lors de l\'import:', error);
            showErrorMessage(`Erreur lors de l'import: ${error.message}`);
        }
    };

    reader.onerror = function() {
        showErrorMessage('Erreur lors de la lecture du fichier');
    };

    // Lecture du fichier selon son type
    if (file.name.endsWith('.json')) {
        reader.readAsText(file);
    } else {
        reader.readAsArrayBuffer(file);
    }
}

async function handleJsonImport(jsonString) {
    const importedData = JSON.parse(jsonString);
    
    // Validation des données
    if (!validateImportedData(importedData)) {
        throw new Error('Format de données invalide');
    }

    // Fusion ou remplacement des données
    await mergeOrReplaceData(importedData);
}

async function handleExcelImport(arrayBuffer) {
    const workbook = XLSX.read(arrayBuffer);
    
    // Validation de la structure du fichier
    validateExcelStructure(workbook);

    // Conversion des données
    const convertedData = convertExcelToAppData(workbook);
    
    // Import des données converties
    await mergeOrReplaceData(convertedData);
}

// ===============================================
// GESTION DES DONNÉES
// ===============================================

function mergeOrReplaceData(importedData) {
    return new Promise((resolve, reject) => {
        try {
            if (AppState.regulations.length > 0) {
                showConfirmDialog(
                    'Données existantes détectées',
                    'Voulez-vous fusionner les données ou remplacer les existantes ?',
                    {
                        merge: () => handleDataMerge(importedData),
                        replace: () => handleDataReplace(importedData),
                        cancel: () => reject(new Error('Import annulé'))
                    }
                );
            } else {
                handleDataReplace(importedData);
                resolve();
            }
        } catch (error) {
            reject(error);
        }
    });
}

function handleDataMerge(importedData) {
    // Création d'un index des données existantes
    const existingIndex = new Map(
        AppState.regulations.map(reg => [reg.id, reg])
    );

    // Fusion des données
    importedData.regulations.forEach(importedReg => {
        const existing = existingIndex.get(importedReg.id);
        
        if (existing) {
            // Mise à jour de la régulation existante
            Object.assign(existing, mergeRegulationData(existing, importedReg));
        } else {
            // Ajout de la nouvelle régulation
            AppState.regulations.push(importedReg);
        }
    });

    // Mise à jour des liens et références
    updateAllReferences();
}

function handleDataReplace(importedData) {
    AppState.regulations = importedData.regulations;
    updateAllReferences();
}

// ===============================================
// FONCTIONS UTILITAIRES
// ===============================================

function validateImportedData(data) {
    const requiredStructure = {
        regulations: Array.isArray,
        version: value => typeof value === 'string',
        metadata: value => typeof value === 'object'
    };

    return validateObjectStructure(data, requiredStructure) &&
           data.regulations.every(validateRegulationStructure);
}

function validateRegulationStructure(regulation) {
    const requiredFields = {
        id: 'string',
        category: 'string',
        text: 'string',
        status: 'string',
        actions: 'array',
        raci: 'object'
    };

    return Object.entries(requiredFields).every(([field, type]) => {
        const value = regulation[field];
        return value !== undefined && 
               (typeof value === type || (type === 'array' && Array.isArray(value)));
    });
}

function validateExcelStructure(workbook) {
    const requiredSheets = ['Réglementations', 'Actions', 'Risques'];
    
    if (!requiredSheets.every(sheet => workbook.SheetNames.includes(sheet))) {
        throw new Error('Structure Excel invalide: feuilles manquantes');
    }
}

function convertExcelToAppData(workbook) {
    const regulations = [];
    
    // Conversion de la feuille des réglementations
    const regSheet = workbook.Sheets['Réglementations'];
    const regData = XLSX.utils.sheet_to_json(regSheet);

    regData.forEach(row => {
        const regulation = convertExcelRowToRegulation(row);
        regulations.push(regulation);
    });

    // Ajout des actions
    const actionSheet = workbook.Sheets['Actions'];
    const actionData = XLSX.utils.sheet_to_json(actionSheet);
    
    addActionsToRegulations(regulations, actionData);

    // Ajout des risques
    const riskSheet = workbook.Sheets['Risques'];
    const riskData = XLSX.utils.sheet_to_json(riskSheet);
    
    addRisksToActions(regulations, riskData);

    return { regulations, version: '1.0', metadata: { importedAt: new Date() } };
}

function updateAllReferences() {
    // Mise à jour des liens entre régulations
    AppState.regulations.forEach(reg => {
        if (reg.category === 'Level 1') {
            updateLevel1Links(reg);
        } else {
            updateSubordinateLinks(reg);
        }
    });

    // Recalcul des statistiques
    recalculateAllMetrics();
}

// ===============================================
// FONCTIONS DE SUPPORT
// ===============================================

function showConfirmDialog(title, message, handlers) {
    const dialog = document.createElement('div');
    dialog.className = 'confirm-dialog';
    
    dialog.innerHTML = `
        <div class="confirm-dialog-content">
            <h3>${title}</h3>
            <p>${message}</p>
            <div class="confirm-dialog-actions">
                <button class="button" data-action="merge">Fusionner</button>
                <button class="button" data-action="replace">Remplacer</button>
                <button class="button secondary" data-action="cancel">Annuler</button>
            </div>
        </div>
    `;

    document.body.appendChild(dialog);

    // Gestionnaires d'événements
    dialog.addEventListener('click', e => {
        const action = e.target.dataset.action;
        if (handlers[action]) {
            handlers[action]();
            dialog.remove();
        }
    });
}

function formatDate(date) {
    if (!date) return '';
    const d = new Date(date);
    return d.toISOString().split('T')[0];
}

function downloadFile(dataUri, fileName) {
    const link = document.createElement('a');
    link.href = dataUri;
    link.download = fileName;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
}

function detectFileType(fileName) {
    const extension = fileName.split('.').pop().toLowerCase();
    return extension;
}

function logExportActivity(fileName) {
    const log = {
        type: 'export',
        fileName,
        timestamp: new Date().toISOString(),
        user: AppState.currentUser,
        totalRegulations: AppState.regulations.length
    };

    // Ajout au journal d'activité
    AppState.activityLog.push(log);
    saveActivityLog();
}

// ===============================================
// GESTION DES COMPOSANTS UI
// ===============================================

class UIComponentManager {
    constructor() {
        // Initialisation des propriétés
        this.components = new Map();
        this.eventHandlers = new Map();
        this.templates = {};
        this.delegatedEvents = new Map();
        this.registeredComponents = new Map();

        // Bind des méthodes de base essentielles
        this.init = this.init.bind(this);
        this.handleDelegatedEvent = this.handleDelegatedEvent.bind(this);
        this.loadTemplates = this.loadTemplates.bind(this);
        this.setupEventDelegation = this.setupEventDelegation.bind(this);

        // Initialisation des gestionnaires d'événements de base
        this.initializeEventHandlers();

        // Démarrage de l'initialisation
        this.init();
    }

    initializeEventHandlers() {
        // Définition des gestionnaires d'événements de base
        this.eventHandlers = {
            // Gestionnaires de régulation
            handleRegulationClick: (event) => {
                const regulation = event.target.closest('.regulation-item');
                if (regulation) {
                    this.toggleRegulation(regulation);
                }
            },

            handleStatusChange: (event) => {
                const regulation = event.target.closest('.regulation-item');
                if (regulation) {
                    this.updateStatus(regulation.dataset.id, event.target.value);
                }
            },

            // Gestionnaires d'actions
            handleActionAdd: (event) => {
                const regulation = event.target.closest('.regulation-item');
                if (regulation) {
                    this.addAction(regulation.dataset.id);
                }
            },

            handleActionDelete: (event) => {
                const action = event.target.closest('.action-item');
                const regulation = action?.closest('.regulation-item');
                if (action && regulation) {
                    this.deleteAction(regulation.dataset.id, action.dataset.id);
                }
            },

            // Gestionnaires RACI
            handleRaciUpdate: (event) => {
                const input = event.target;
                const regulation = input.closest('.regulation-item');
                if (regulation && input.dataset.raci) {
                    this.updateRaci(
                        regulation.dataset.id,
                        input.dataset.raci,
                        input.value
                    );
                }
            },

            // Gestionnaires de recherche et filtres
            handleSearch: (event) => {
                this.updateSearch(event.target.value);
            },

            handleFilterChange: (event) => {
                const filter = event.target.closest('[data-filter]');
                if (filter) {
                    this.updateFilter(filter.dataset.filter, filter.dataset.value);
                }
            }
        };

        // Bind de tous les gestionnaires
        Object.keys(this.eventHandlers).forEach(key => {
            this.eventHandlers[key] = this.eventHandlers[key].bind(this);
        });
    }

    bindEventHandler(element, eventType, handler) {
        if (typeof handler === 'string') {
            handler = this.eventHandlers[handler];
        }

        if (!handler) {
            console.warn(`Handler non trouvé pour l'événement ${eventType}`);
            return;
        }

        element.addEventListener(eventType, handler);
        return () => element.removeEventListener(eventType, handler);
    }

    setupEventDelegation() {
        // Délégation des événements de base
        const delegatedEvents = [
            { type: 'click', selector: '.regulation-item', handler: 'handleRegulationClick' },
            { type: 'change', selector: '.status-select', handler: 'handleStatusChange' },
            { type: 'click', selector: '.add-action-btn', handler: 'handleActionAdd' },
            { type: 'click', selector: '.delete-action-btn', handler: 'handleActionDelete' },
            { type: 'input', selector: '.raci-input', handler: 'handleRaciUpdate' },
            { type: 'input', selector: '#searchInput', handler: 'handleSearch' },
            { type: 'click', selector: '[data-filter]', handler: 'handleFilterChange' }
        ];

        delegatedEvents.forEach(({ type, selector, handler }) => {
            this.delegateEvent(type, selector, this.eventHandlers[handler]);
        });
    }

    delegateEvent(eventType, selector, handler) {
        if (!this.delegatedEvents.has(eventType)) {
            this.delegatedEvents.set(eventType, []);
            document.addEventListener(eventType, this.handleDelegatedEvent);
        }

        this.delegatedEvents.get(eventType).push({
            selector,
            handler: handler.bind(this)
        });
    }

    handleDelegatedEvent(event) {
        const handlers = this.delegatedEvents.get(event.type);
        if (!handlers) return;

        let element = event.target;
        let matched = false;

        while (element && element !== document && !matched) {
            handlers.forEach(({ selector, handler }) => {
                if (!matched && element.matches(selector)) {
                    handler.call(this, event);
                    matched = true;
                }
            });
            element = element.parentElement;
        }
    }

    // Méthodes d'action UI
    toggleRegulation(regulation) {
        const content = regulation.querySelector('.regulation-content');
        const isExpanded = content.classList.toggle('expanded');
        const toggle = regulation.querySelector('.regulation-toggle');
        if (toggle) {
            toggle.textContent = isExpanded ? '▼' : '▶';
        }
    }

    updateStatus(regulationId, status) {
        try {
            // Mise à jour du statut
            const regulation = this.components.get(regulationId);
            if (regulation) {
                regulation.status = status;
                this.updateUI();
            }
        } catch (error) {
            console.error('Erreur lors de la mise à jour du statut:', error);
            this.showError('Erreur lors de la mise à jour du statut');
        }
    }

    updateSearch(term) {
        try {
            this.searchTerm = term;
            this.updateUI();
        } catch (error) {
            console.error('Erreur lors de la recherche:', error);
            this.showError('Erreur lors de la recherche');
        }
    }

    updateFilter(type, value) {
        try {
            this.filters[type] = value;
            this.updateUI();
        } catch (error) {
            console.error('Erreur lors du filtrage:', error);
            this.showError('Erreur lors du filtrage');
        }
    }

    // Gestion des erreurs
    showError(message) {
        const errorElement = document.createElement('div');
        errorElement.className = 'error-notification';
        errorElement.textContent = message;
        document.body.appendChild(errorElement);
        setTimeout(() => errorElement.remove(), 5000);
    }

    init() {
        try {
            this.loadTemplates();
            this.setupEventDelegation();
            this.initializeComponents();
        } catch (error) {
            console.error('Erreur lors de l\'initialisation:', error);
            this.handleInitError(error);
        }
    }

    // Gestionnaires d'événements spécifiques avec le bon contexte
    handleRegulationHeaderClick(event, element) {
        const regulationItem = element.closest('.regulation-item');
        if (!regulationItem) return;

        const content = regulationItem.querySelector('.regulation-content');
        const toggle = regulationItem.querySelector('.regulation-toggle');

        if (content && toggle) {
            content.classList.toggle('expanded');
            toggle.textContent = content.classList.contains('expanded') ? '▼' : '▶';
        }

        event.stopPropagation();
    }

    handleStatusChange(event, element) {
        const regulationId = element.closest('.regulation-item')?.dataset.id;
        if (!regulationId) return;

        const newStatus = element.value;
        this.updateRegulationStatus(regulationId, newStatus);
    }

    handleRaciUpdate(event, element) {
        const regulationItem = element.closest('.regulation-item');
        if (!regulationItem) return;

        const regulationId = regulationItem.dataset.id;
        const role = element.dataset.raci;
        const value = element.value.trim();

        if (regulationId && role) {
            this.updateRaci(regulationId, role, value);
        }
    }

    // Méthodes de mise à jour UI sécurisées
    updateRegulationStatus(regulationId, status) {
        try {
            const regulation = this.components.get(regulationId);
            if (!regulation) return;

            regulation.status = status;
            this.updateRegulationUI(regulationId);
            this.notifyStateChange();
        } catch (error) {
            console.error('Erreur lors de la mise à jour du statut:', error);
            this.showErrorNotification('Erreur lors de la mise à jour du statut');
        }
    }

    updateRaci(regulationId, role, value) {
        try {
            const regulation = this.components.get(regulationId);
            if (!regulation) return;

            regulation.raci = regulation.raci || {};
            regulation.raci[role] = value;
            this.updateRegulationUI(regulationId);
            this.notifyStateChange();
        } catch (error) {
            console.error('Erreur lors de la mise à jour RACI:', error);
            this.showErrorNotification('Erreur lors de la mise à jour RACI');
        }
    }

    // Gestionnaire d'erreurs centralisé
    handleError(error, context) {
        console.error(`Erreur dans ${context}:`, error);
        this.showErrorNotification(`Une erreur est survenue: ${error.message}`);
    }

    // Utilitaires
    notifyStateChange() {
        // Déclencher un événement personnalisé pour la mise à jour de l'état
        const event = new CustomEvent('stateChange', {
            detail: {
                timestamp: new Date().getTime()
            }
        });
        document.dispatchEvent(event);
    }

    updateRegulationUI(regulationId) {
        const element = document.querySelector(`[data-id="${regulationId}"]`);
        if (!element) return;

        const regulation = this.components.get(regulationId);
        if (!regulation) return;

        // Mise à jour du statut
        const statusSelect = element.querySelector('.status-select');
        if (statusSelect) {
            statusSelect.value = regulation.status;
        }

        // Mise à jour RACI
        if (regulation.raci) {
            Object.entries(regulation.raci).forEach(([role, value]) => {
                const input = element.querySelector(`[data-raci="${role}"]`);
                if (input) {
                    input.value = value;
                }
            });
        }
    }

    registerComponent(name, options) {
        if (this.registeredComponents.has(name)) {
            console.warn(`Le composant '${name}' est déjà enregistré`);
            return;
        }

        const defaultOptions = {
            template: null,
            render: () => {},
            update: () => {},
            destroy: () => {},
            events: {},
            handlers: {},
            state: {},
            lifecycle: {
                beforeMount: () => {},
                mounted: () => {},
                beforeUpdate: () => {},
                updated: () => {},
                beforeDestroy: () => {}
            }
        };

        const componentConfig = {
            ...defaultOptions,
            ...options,
            name
        };

        this.registeredComponents.set(name, componentConfig);
        this.setupComponentMethods(name, componentConfig);
    }

    setupComponentMethods(name, config) {
        // Méthode de création d'instance
        this[`create${name}`] = (props = {}) => {
            return this.createComponentInstance(name, props);
        };

        // Méthode de mise à jour
        this[`update${name}`] = (instance, updates) => {
            return this.updateComponentInstance(instance, updates);
        };
    }

    createComponentInstance(name, props) {
        const config = this.registeredComponents.get(name);
        if (!config) {
            throw new Error(`Composant '${name}' non trouvé`);
        }

        // Création de l'état initial
        const state = {
            ...config.state,
            ...props
        };

        // Création de l'élément
        const element = this.createElementFromTemplate(config.template, state);

        // Création de l'instance
        const instance = {
            name,
            element,
            state,
            props,
            config,
            handlers: {},
            refs: this.collectRefs(element)
        };

        // Ajout des méthodes de l'instance
        this.addInstanceMethods(instance);

        // Exécution du cycle de vie
        config.lifecycle.beforeMount.call(instance);
        
        // Rendu initial
        config.render.call(instance, state);
        
        // Attachement des événements
        this.attachComponentEvents(instance);

        // Montage terminé
        config.lifecycle.mounted.call(instance);

        return instance;
    }

    updateComponentInstance(instance, updates) {
        const { config, state } = instance;

        // Vérification du cycle de vie
        config.lifecycle.beforeUpdate.call(instance, updates);

        // Mise à jour de l'état
        Object.assign(state, updates);

        // Mise à jour du DOM
        config.update.call(instance, updates);

        // Mise à jour terminée
        config.lifecycle.updated.call(instance, updates);
    }

    destroyComponent(instance) {
        const { config, element } = instance;

        // Vérification du cycle de vie
        config.lifecycle.beforeDestroy.call(instance);

        // Détachement des événements
        this.detachComponentEvents(instance);

        // Nettoyage du DOM
        if (element && element.parentNode) {
            element.parentNode.removeChild(element);
        }

        // Suppression des références
        this.registeredComponents.delete(instance.name);
    }

    // Méthodes utilitaires pour les composants
    createElementFromTemplate(template, state) {
        if (typeof template === 'string') {
            const div = document.createElement('div');
            div.innerHTML = this.interpolateTemplate(template, state);
            return div.firstElementChild;
        } else if (template instanceof Element) {
            return template.cloneNode(true);
        }
        throw new Error('Template invalide');
    }

    interpolateTemplate(template, state) {
        return template.replace(/\{\{\s*(\w+)\s*\}\}/g, (_, key) => {
            return state[key] != null ? state[key] : '';
        });
    }

    collectRefs(element) {
        const refs = {};
        element.querySelectorAll('[data-ref]').forEach(el => {
            refs[el.dataset.ref] = el;
        });
        return refs;
    }

    addInstanceMethods(instance) {
        // Méthodes d'état
        instance.setState = (updates) => {
            this.updateComponentInstance(instance, updates);
        };

        // Méthodes de rendu
        instance.forceUpdate = () => {
            instance.config.render.call(instance, instance.state);
        };

        // Méthodes d'événements
        instance.on = (eventType, handler) => {
            this.addComponentEventHandler(instance, eventType, handler);
        };

        instance.off = (eventType) => {
            this.removeComponentEventHandler(instance, eventType);
        };
    }

    attachComponentEvents(instance) {
        const { config, element, handlers } = instance;

        // Attache les gestionnaires d'événements définis dans la configuration
        Object.entries(config.events).forEach(([eventType, handler]) => {
            const [type, selector] = eventType.split(':');
            const boundHandler = handler.bind(instance);

            if (selector) {
                element.querySelectorAll(selector).forEach(el => {
                    el.addEventListener(type, boundHandler);
                    handlers[eventType] = boundHandler;
                });
            } else {
                element.addEventListener(type, boundHandler);
                handlers[eventType] = boundHandler;
            }
        });
    }

    detachComponentEvents(instance) {
        const { element, handlers } = instance;

        // Détache tous les gestionnaires d'événements
        Object.entries(handlers).forEach(([eventType, handler]) => {
            const [type, selector] = eventType.split(':');
            if (selector) {
                element.querySelectorAll(selector).forEach(el => {
                    el.removeEventListener(type, handler);
                });
            } else {
                element.removeEventListener(type, handler);
            }
        });

        // Vide la liste des gestionnaires
        instance.handlers = {};
    }

    // Méthodes de gestion des événements spécifiques aux composants
    addComponentEventHandler(instance, eventType, handler) {
        const { element, handlers } = instance;
        const boundHandler = handler.bind(instance);
        
        const [type, selector] = eventType.split(':');
        if (selector) {
            element.querySelectorAll(selector).forEach(el => {
                el.addEventListener(type, boundHandler);
            });
        } else {
            element.addEventListener(type, boundHandler);
        }
        
        handlers[eventType] = boundHandler;
    }

    removeComponentEventHandler(instance, eventType) {
        const { element, handlers } = instance;
        const handler = handlers[eventType];
        if (!handler) return;

        const [type, selector] = eventType.split(':');
        if (selector) {
            element.querySelectorAll(selector).forEach(el => {
                el.removeEventListener(type, handler);
            });
        } else {
            element.removeEventListener(type, handler);
        }

        delete handlers[eventType];
    }

    // Utilitaires supplémentaires
    findComponent(element) {
        return Array.from(this.registeredComponents.values())
            .find(comp => element.matches(`[data-component="${comp.name}"]`));
    }

    getComponentInstance(element) {
        return this.components.get(element);
    }

    getAllInstances(componentName) {
        return Array.from(this.components.values())
            .filter(instance => instance.name === componentName);
    }

    // Initialisation des composants dynamiques
    initializeComponents() {
        // Composant de régulation
        this.registerComponent('regulation-item', {
            render: this.renderRegulationItem.bind(this),
            update: this.updateRegulationItem.bind(this),
            handlers: this.regulationHandlers
        });

        // Composant d'action
        this.registerComponent('action-item', {
            render: this.renderActionItem.bind(this),
            update: this.updateActionItem.bind(this),
            handlers: this.actionHandlers
        });

        // Composant RACI
        this.registerComponent('raci-matrix', {
            render: this.renderRaciMatrix.bind(this),
            update: this.updateRaciMatrix.bind(this),
            handlers: this.raciHandlers
        });

        // Autres composants...
        this.initializeAdditionalComponents();
    }

    // Rendu des composants principaux
    renderRegulationItem(regulation) {
        const template = this.templates.regulationItem;
        const element = template.cloneNode(true);

        // Remplissage des données de base
        element.querySelector('.regulation-id').textContent = regulation.id;
        element.querySelector('.regulation-text').textContent = regulation.text;
        element.querySelector('.regulation-category').textContent = regulation.category;

        // Configuration du statut
        this.setupStatusSelect(element, regulation);

        // Rendu des sous-composants
        this.renderSubComponents(element, regulation);

        // Configuration des gestionnaires d'événements
        this.setupRegulationEventHandlers(element, regulation);

        return element;
    }

    renderActionItem(action, regulationId) {
        const template = this.templates.actionItem;
        const element = template.cloneNode(true);

        element.dataset.actionId = action.id;
        element.dataset.regulationId = regulationId;

        // Remplissage des données
        element.querySelector('.action-text').textContent = action.text;
        element.querySelector('.action-progress').value = action.percentage;

        // Configuration de la barre de progression
        this.setupProgressBar(element, action);

        // Rendu des risques associés
        this.renderActionRisks(element, action);

        // Configuration des gestionnaires d'événements
        this.setupActionEventHandlers(element, action, regulationId);

        return element;
    }

    // Gestionnaires d'événements spécifiques
    setupRegulationEventHandlers(element, regulation) {
        // Gestionnaire de statut
        const statusSelect = element.querySelector('.status-select');
        statusSelect.addEventListener('change', (e) => {
            this.handleStatusChange(regulation.id, e.target.value);
        });

        // Gestionnaire d'expansion/réduction
        const header = element.querySelector('.regulation-header');
        header.addEventListener('click', (e) => {
            if (!e.target.closest('select, button')) {
                this.toggleRegulationContent(element);
            }
        });

        // Gestionnaires RACI
        const raciInputs = element.querySelectorAll('.raci-input');
        raciInputs.forEach(input => {
            input.addEventListener('change', (e) => {
                this.handleRaciUpdate(regulation.id, {
                    [e.target.dataset.role]: e.target.value
                });
            });
        });
    }

    setupActionEventHandlers(element, action, regulationId) {
        // Gestionnaire de progression
        const progressInput = element.querySelector('.progress-input');
        progressInput.addEventListener('input', this.debounce((e) => {
            this.handleProgressUpdate(regulationId, action.id, e.target.value);
        }, 300));

        // Gestionnaire de suppression
        const deleteBtn = element.querySelector('.delete-action');
        deleteBtn.addEventListener('click', () => {
            this.handleActionDelete(regulationId, action.id);
        });

        // Gestionnaire de risques
        const addRiskBtn = element.querySelector('.add-risk');
        addRiskBtn.addEventListener('click', () => {
            this.showRiskDialog(regulationId, action.id);
        });
    }

    // Gestion des mises à jour UI
    updateRegulationItem(element, updates) {
        // Mise à jour optimisée: ne mettre à jour que ce qui a changé
        Object.entries(updates).forEach(([key, value]) => {
            switch (key) {
                case 'status':
                    this.updateStatus(element, value);
                    break;
                case 'text':
                    this.updateText(element, value);
                    break;
                case 'raci':
                    this.updateRaci(element, value);
                    break;
                case 'actions':
                    this.updateActions(element, value);
                    break;
                // Autres cas...
            }
        });

        // Animation de mise à jour
        this.animateUpdate(element);
    }

    // Animations et transitions
    animateUpdate(element) {
        element.classList.add('updating');
        requestAnimationFrame(() => {
            element.classList.remove('updating');
        });
    }

    // Gestion des dialogues et modaux
    showRiskDialog(regulationId, actionId) {
        const dialog = this.createRiskDialog(regulationId, actionId);
        document.body.appendChild(dialog);

        // Animation d'entrée
        requestAnimationFrame(() => {
            dialog.classList.add('visible');
        });
    }

    createRiskDialog(regulationId, actionId) {
        const dialog = document.createElement('div');
        dialog.className = 'risk-dialog';
        dialog.innerHTML = `
            <div class="risk-dialog-content">
                <h3>Ajouter un risque</h3>
                <form class="risk-form">
                    <div class="form-group">
                        <label for="riskDescription">Description</label>
                        <textarea id="riskDescription" class="input" required></textarea>
                    </div>
                    <div class="form-group">
                        <label for="riskSeverity">Sévérité</label>
                        <select id="riskSeverity" class="input" required>
                            <option value="low">Faible</option>
                            <option value="medium">Moyenne</option>
                            <option value="high">Haute</option>
                            <option value="critical">Critique</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="riskLikelihood">Probabilité</label>
                        <select id="riskLikelihood" class="input" required>
                            <option value="rare">Rare</option>
                            <option value="unlikely">Peu probable</option>
                            <option value="possible">Possible</option>
                            <option value="likely">Probable</option>
                            <option value="almost-certain">Quasi certain</option>
                        </select>
                    </div>
                    <div class="dialog-actions">
                        <button type="submit" class="button">Ajouter</button>
                        <button type="button" class="button secondary" data-action="cancel">
                            Annuler
                        </button>
                    </div>
                </form>
            </div>
        `;

        // Configuration des gestionnaires
        this.setupRiskDialogHandlers(dialog, regulationId, actionId);

        return dialog;
    }

    // Composants d'interaction utilisateur
    createTooltip(element, text) {
        const tooltip = document.createElement('div');
        tooltip.className = 'tooltip';
        tooltip.textContent = text;

        // Positionnement et affichage
        this.positionTooltip(tooltip, element);

        return tooltip;
    }

    createContextMenu(items) {
        const menu = document.createElement('div');
        menu.className = 'context-menu';

        items.forEach(item => {
            const menuItem = document.createElement('div');
            menuItem.className = 'context-menu-item';
            menuItem.textContent = item.label;
            menuItem.addEventListener('click', item.action);
            menu.appendChild(menuItem);
        });

        return menu;
    }

    // Gestion des notifications
    showNotification(message, type = 'info', duration = 3000) {
        const notification = document.createElement('div');
        notification.className = `notification ${type}`;
        notification.innerHTML = `
            <div class="notification-content">
                <span class="notification-icon">${this.getNotificationIcon(type)}</span>
                <span class="notification-message">${message}</span>
            </div>
        `;

        // Gestion de la file d'attente des notifications
        this.notificationQueue.push(notification);
        this.processNotificationQueue();

        // Auto-suppression
        setTimeout(() => {
            notification.classList.add('hiding');
            setTimeout(() => {
                notification.remove();
                this.notificationQueue = this.notificationQueue
                    .filter(n => n !== notification);
            }, 300);
        }, duration);
    }

    // Gestion de l'état de chargement
    showLoading(element, text = 'Chargement...') {
        const loader = document.createElement('div');
        loader.className = 'loading-overlay';
        loader.innerHTML = `
            <div class="loading-spinner"></div>
            <div class="loading-text">${text}</div>
        `;

        element.classList.add('loading');
        element.appendChild(loader);

        return () => {
            element.classList.remove('loading');
            loader.remove();
        };
    }

    // Utilitaires
    debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
            const later = () => {
                clearTimeout(timeout);
                func(...args);
            };
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
        };
    }

    throttle(func, limit) {
        let inThrottle;
        return function executedFunction(...args) {
            if (!inThrottle) {
                func(...args);
                inThrottle = true;
                setTimeout(() => inThrottle = false, limit);
            }
        };
    }

    loadTemplates() {
        // Chargement des templates depuis le DOM
        const templateIds = [
            'regulationTemplate',
            'actionTemplate',
            'riskTemplate'
        ];

        templateIds.forEach(id => {
            const template = document.getElementById(id);
            if (template) {
                // Cloner le contenu du template
                const content = template.content.cloneNode(true);
                // Stocker le contenu cloné
                this.templates[id] = content.firstElementChild;
            } else {
                console.error(`Template '${id}' non trouvé dans le DOM`);
            }
        });

        // Templates dynamiques créés par programmation
        this.templates.notification = this.createNotificationTemplate();
        this.templates.tooltip = this.createTooltipTemplate();
        this.templates.contextMenu = this.createContextMenuTemplate();
        this.templates.modal = this.createModalTemplate();
        this.templates.confirmDialog = this.createConfirmDialogTemplate();
    }

    createNotificationTemplate() {
        const div = document.createElement('div');
        div.className = 'notification';
        div.innerHTML = `
            <div class="notification-content">
                <span class="notification-icon"></span>
                <span class="notification-message"></span>
                <button class="notification-close">&times;</button>
            </div>
        `;
        return div;
    }

    createTooltipTemplate() {
        const div = document.createElement('div');
        div.className = 'tooltip';
        return div;
    }

    createContextMenuTemplate() {
        const div = document.createElement('div');
        div.className = 'context-menu';
        return div;
    }

    createModalTemplate() {
        const div = document.createElement('div');
        div.className = 'modal';
        div.innerHTML = `
            <div class="modal-overlay"></div>
            <div class="modal-container">
                <div class="modal-header">
                    <h3 class="modal-title"></h3>
                    <button class="modal-close">&times;</button>
                </div>
                <div class="modal-content"></div>
                <div class="modal-footer"></div>
            </div>
        `;
        return div;
    }

    createConfirmDialogTemplate() {
        const div = document.createElement('div');
        div.className = 'confirm-dialog';
        div.innerHTML = `
            <div class="confirm-dialog-content">
                <h3 class="confirm-dialog-title"></h3>
                <p class="confirm-dialog-message"></p>
                <div class="confirm-dialog-actions">
                    <button class="button confirm-yes">Confirmer</button>
                    <button class="button secondary confirm-no">Annuler</button>
                </div>
            </div>
        `;
        return div;
    }

    // Méthode utilitaire pour cloner un template
    cloneTemplate(templateId) {
        const template = this.templates[templateId];
        if (!template) {
            throw new Error(`Template '${templateId}' non trouvé`);
        }
        return template.cloneNode(true);
    }

    // Méthode pour recréer un template si nécessaire
    resetTemplate(templateId) {
        const templateElement = document.getElementById(templateId);
        if (templateElement) {
            const content = templateElement.content.cloneNode(true);
            this.templates[templateId] = content.firstElementChild;
        }
    }

    // Méthode pour vérifier si tous les templates requis sont chargés
    validateTemplates() {
        const requiredTemplates = [
            'regulationTemplate',
            'actionTemplate',
            'riskTemplate'
        ];

        const missingTemplates = requiredTemplates.filter(
            id => !this.templates[id]
        );

        if (missingTemplates.length > 0) {
            throw new Error(
                `Templates manquants : ${missingTemplates.join(', ')}`
            );
        }
    }

    // Méthode pour créer dynamiquement un template personnalisé
    createCustomTemplate(id, html) {
        const template = document.createElement('div');
        template.innerHTML = html;
        this.templates[id] = template.firstElementChild;
        return this.templates[id];
    }

    // Méthode pour mettre à jour un template existant
    updateTemplate(templateId, updateFn) {
        const template = this.templates[templateId];
        if (template) {
            updateFn(template);
        } else {
            console.error(`Template '${templateId}' non trouvé pour la mise à jour`);
        }
    }

    setupSpecificEventDelegation() {
        // Événements pour les régulations
        this.delegateEvent('click', '.regulation-header', this.handleRegulationHeaderClick);
        this.delegateEvent('change', '.status-select', this.handleStatusChange);
        this.delegateEvent('click', '.regulation-delete', this.handleRegulationDelete);

        // Événements pour les actions
        this.delegateEvent('click', '.add-action-btn', this.handleAddAction);
        this.delegateEvent('input', '.action-progress', this.handleProgressUpdate);
        this.delegateEvent('click', '.action-delete', this.handleActionDelete);

        // Événements pour la matrice RACI
        this.delegateEvent('input', '.raci-input', this.handleRaciUpdate);
        this.delegateEvent('click', '.raci-toggle', this.handleRaciToggle);

        // Événements pour les risques
        this.delegateEvent('click', '.add-risk-btn', this.handleAddRisk);
        this.delegateEvent('click', '.risk-delete', this.handleRiskDelete);

        // Événements pour les formulaires
        this.delegateEvent('submit', '.regulation-form', this.handleFormSubmit);
        this.delegateEvent('reset', '.regulation-form', this.handleFormReset);

        // Événements pour les filtres et la recherche
        this.delegateEvent('input', '#searchInput', this.handleSearch);
        this.delegateEvent('click', '.category-filter', this.handleCategoryFilter);
        this.delegateEvent('click', '.status-tab', this.handleStatusFilter);
    }

    handleStatusChange(event, ui) {
        const regulationId = this.closest('.regulation-item').dataset.id;
        const newStatus = this.value;

        ui.updateRegulationStatus(regulationId, newStatus);
    }

    handleRegulationDelete(event, ui) {
        const regulationId = this.closest('.regulation-item').dataset.id;
        
        if (confirm('Êtes-vous sûr de vouloir supprimer cette régulation ?')) {
            ui.deleteRegulation(regulationId);
        }
    }

    handleAddAction(event, ui) {
        const regulationItem = this.closest('.regulation-item');
        const actionInput = regulationItem.querySelector('.action-input');
        
        if (actionInput.value.trim()) {
            ui.addAction(regulationItem.dataset.id, {
                text: actionInput.value.trim()
            });
            actionInput.value = '';
        }
    }

    handleProgressUpdate(event, ui) {
        const actionItem = this.closest('.action-item');
        const regulationId = actionItem.closest('.regulation-item').dataset.id;
        const actionId = actionItem.dataset.id;
        const progress = parseInt(this.value) || 0;

        ui.updateActionProgress(regulationId, actionId, progress);
    }

    // Gestionnaires de formulaires
    handleFormSubmit(event, ui) {
        event.preventDefault();
        
        const formData = new FormData(this);
        const regulationData = Object.fromEntries(formData.entries());

        ui.submitRegulation(regulationData);
    }

    handleFormReset(event, ui) {
        event.preventDefault();
        ui.resetForm(this);
    }

    // Gestionnaires de recherche et filtres
    handleSearch(event, ui) {
        const searchTerm = this.value.trim();
        ui.updateSearch(searchTerm);
    }

    handleCategoryFilter(event, ui) {
        const category = this.dataset.category;
        document.querySelectorAll('.category-filter').forEach(f => 
            f.classList.toggle('active', f === this)
        );
        ui.updateCategoryFilter(category);
    }

    handleStatusFilter(event, ui) {
        const status = this.dataset.status;
        document.querySelectorAll('.status-tab').forEach(t => 
            t.classList.toggle('active', t === this)
        );
        ui.updateStatusFilter(status);
    }

    // Méthodes utilitaires pour les événements
    addGlobalEventListener(eventType, handler) {
        document.addEventListener(eventType, handler);
        return () => document.removeEventListener(eventType, handler);
    }

    addDynamicEventListener(eventType, selector, handler) {
        this.delegateEvent(eventType, selector, handler);
    }

    removeDynamicEventListener(eventType, selector) {
        const handlers = this.delegatedEvents.get(eventType);
        if (handlers) {
            const index = handlers.findIndex(h => h.selector === selector);
            if (index !== -1) {
                handlers.splice(index, 1);
            }
        }
    }

    // Gestion des événements pour les composants dynamiques
    attachComponentEvents(element, events) {
        Object.entries(events).forEach(([eventType, handler]) => {
            const [type, selector] = eventType.split(':');
            if (selector) {
                element.querySelectorAll(selector).forEach(el => 
                    el.addEventListener(type, handler)
                );
            } else {
                element.addEventListener(type, handler);
            }
        });
    }

    detachComponentEvents(element, events) {
        Object.entries(events).forEach(([eventType, handler]) => {
            const [type, selector] = eventType.split(':');
            if (selector) {
                element.querySelectorAll(selector).forEach(el => 
                    el.removeEventListener(type, handler)
                );
            } else {
                element.removeEventListener(type, handler);
            }
        });
    }

    // Nettoyage des événements
    cleanupEvents() {
        this.delegatedEvents.clear();
        // Nettoyage des autres écouteurs d'événements si nécessaire
    }
    
    // ===============================================
    // Gestionnaires RACI
    // ===============================================
    handleRaciToggle(event, element) {
        const raciContainer = element.closest('.raci-container');
        if (!raciContainer) return;
    
        const raciGrid = raciContainer.querySelector('.raci-grid');
        const toggle = raciContainer.querySelector('.raci-toggle');
        
        const isCollapsed = raciContainer.classList.toggle('raci-collapsed');
        if (toggle) {
            toggle.textContent = isCollapsed ? '▼' : '▲';
        }
    
        // Animation fluide
        if (raciGrid) {
            if (isCollapsed) {
                raciGrid.style.maxHeight = '0';
            } else {
                raciGrid.style.maxHeight = `${raciGrid.scrollHeight}px`;
            }
        }
    }
    
    // ===============================================
    // Gestionnaires de Risques
    // ===============================================
    handleAddRisk(event, element) {
        const actionItem = element.closest('.action-item');
        if (!actionItem) return;
    
        const regulationId = actionItem.closest('.regulation-item')?.dataset.id;
        const actionId = actionItem.dataset.id;
    
        if (regulationId && actionId) {
            this.showRiskDialog(regulationId, actionId);
        }
    }
    
    handleRiskDelete(event, element) {
        const riskItem = element.closest('.risk-item');
        if (!riskItem) return;
    
        const actionItem = riskItem.closest('.action-item');
        const regulationItem = actionItem?.closest('.regulation-item');
    
        if (!actionItem || !regulationItem) return;
    
        const riskId = riskItem.dataset.id;
        const actionId = actionItem.dataset.id;
        const regulationId = regulationItem.dataset.id;
    
        if (confirm('Êtes-vous sûr de vouloir supprimer ce risque ?')) {
            this.deleteRisk(regulationId, actionId, riskId);
        }
    }
    
    setupRiskDialogHandlers(dialog, regulationId, actionId) {
        const form = dialog.querySelector('.risk-form');
        const cancelButton = dialog.querySelector('[data-action="cancel"]');
    
        form.addEventListener('submit', (e) => {
            e.preventDefault();
            
            const riskData = {
                description: form.querySelector('#riskDescription').value,
                severity: form.querySelector('#riskSeverity').value,
                likelihood: form.querySelector('#riskLikelihood').value
            };
    
            this.addRisk(regulationId, actionId, riskData);
            dialog.classList.remove('visible');
            setTimeout(() => dialog.remove(), 300);
        });
    
        cancelButton.addEventListener('click', () => {
            dialog.classList.remove('visible');
            setTimeout(() => dialog.remove(), 300);
        });
    }
    
    // ===============================================
    // Gestionnaires Tactiles
    // ===============================================
    handleTouchStart(event) {
        this.touchStartX = event.touches[0].clientX;
        this.touchStartY = event.touches[0].clientY;
    }
    
    handleTouchMove(event) {
        if (!this.touchStartX || !this.touchStartY) return;
    
        const xDiff = this.touchStartX - event.touches[0].clientX;
        const yDiff = this.touchStartY - event.touches[0].clientY;
    
        // Si le mouvement horizontal est plus grand que vertical
        if (Math.abs(xDiff) > Math.abs(yDiff)) {
            event.preventDefault();
            const element = event.target.closest('.regulation-item');
            if (element) {
                // Swipe gauche/droite
                element.style.transform = `translateX(${-xDiff}px)`;
            }
        }
    }
    
    handleTouchEnd(event) {
        const element = event.target.closest('.regulation-item');
        if (!element || !this.touchStartX) return;
    
        const xDiff = this.touchStartX - event.changedTouches[0].clientX;
        const threshold = window.innerWidth * 0.3; // 30% de la largeur de l'écran
    
        if (Math.abs(xDiff) > threshold) {
            // Swipe complet
            if (xDiff > 0) {
                this.handleSwipeLeft(element);
            } else {
                this.handleSwipeRight(element);
            }
        } else {
            // Reset position
            element.style.transform = '';
        }
    
        this.touchStartX = null;
        this.touchStartY = null;
    }
    
    // ===============================================
    // Méthodes de Rendu
    // ===============================================
    renderSubComponents(element, regulation) {
        // Rendu RACI
        this.renderRaciSection(element, regulation.raci);
        
        // Rendu des actions
        this.renderActionsSection(element, regulation.actions);
        
        // Rendu des liens
        this.renderLinksSection(element, regulation);
    }
    
    renderRaciMatrix(data) {
        const template = this.templates.raciMatrix;
        const element = template.cloneNode(true);
    
        // Remplir les champs RACI
        Object.entries(data).forEach(([role, value]) => {
            const input = element.querySelector(`[data-raci="${role}"]`);
            if (input) input.value = value;
        });
    
        return element;
    }
    
    setupStatusSelect(element, regulation) {
        const statusSelect = element.querySelector('.status-select');
        if (!statusSelect) return;
    
        statusSelect.value = regulation.status || 'all';
        
        // Ajouter les classes de style selon le statut
        const statusClasses = {
            'Compliant': 'status-compliant',
            'Non Applicable': 'status-na',
            'Documentation': 'status-doc'
        };
    
        Object.entries(statusClasses).forEach(([status, className]) => {
            if (regulation.status === status) {
                element.classList.add(className);
            }
        });
    }
    
    setupProgressBar(element, action) {
        const progressBar = element.querySelector('.progress-fill');
        const progressText = element.querySelector('.progress-text');
        
        if (!progressBar || !progressText) return;
    
        const percentage = action.percentage || 0;
        progressBar.style.width = `${percentage}%`;
        progressText.textContent = `${percentage}%`;
    
        // Couleur selon la progression
        if (percentage === 100) {
            progressBar.classList.add('complete');
        } else if (percentage >= 75) {
            progressBar.classList.add('almost-complete');
        } else if (percentage >= 25) {
            progressBar.classList.add('in-progress');
        }
    }
    
    renderActionRisks(element, action) {
        const risksList = element.querySelector('.risks-list');
        if (!risksList || !action.risks) return;
    
        action.risks.forEach(risk => {
            const riskElement = this.renderRisk(risk);
            risksList.appendChild(riskElement);
        });
    }
    
    // ===============================================
    // Méthodes Utilitaires
    // ===============================================
    positionTooltip(tooltip, element) {
        const rect = element.getBoundingClientRect();
        const tooltipRect = tooltip.getBoundingClientRect();
    
        // Position par défaut : au-dessus de l'élément
        let top = rect.top - tooltipRect.height - 10;
        let left = rect.left + (rect.width - tooltipRect.width) / 2;
    
        // Ajustements si hors écran
        if (top < 0) {
            top = rect.bottom + 10; // Placer en dessous
        }
        if (left < 0) {
            left = 5;
        } else if (left + tooltipRect.width > window.innerWidth) {
            left = window.innerWidth - tooltipRect.width - 5;
        }
    
        tooltip.style.top = `${top}px`;
        tooltip.style.left = `${left}px`;
    }
    
    getNotificationIcon(type) {
        const icons = {
            'success': '✓',
            'error': '⨯',
            'warning': '⚠',
            'info': 'ℹ'
        };
        return icons[type] || icons.info;
    }
    
    processNotificationQueue() {
        if (!this.notificationQueue) {
            this.notificationQueue = [];
        }
    
        const maxVisible = 3;
        const visibleNotifications = this.notificationQueue.slice(0, maxVisible);
        
        visibleNotifications.forEach((notification, index) => {
            if (!notification.isDisplayed) {
                document.body.appendChild(notification);
                notification.style.bottom = `${(index * 60) + 20}px`;
                notification.isDisplayed = true;
            }
        });
    }
    
    handleInitError(error) {
        console.error('Erreur d\'initialisation:', error);
        this.showNotification(
            'Erreur lors de l\'initialisation de l\'application',
            'error'
        );
    }
    
    saveChanges() {
        try {
            const data = {
                regulations: Array.from(this.components.values()),
                lastSaved: new Date().toISOString()
            };
            
            localStorage.setItem('doraCompliance', JSON.stringify(data));
            this.showNotification('Modifications sauvegardées', 'success');
        } catch (error) {
            console.error('Erreur lors de la sauvegarde:', error);
            this.showNotification('Erreur lors de la sauvegarde', 'error');
        }
    }
    
    initializeAdditionalComponents() {
        // Initialisation des composants supplémentaires
        this.initializeSearchComponent();
        this.initializeFilterComponent();
        this.initializeStatisticsComponent();
        this.initializeExportComponent();
    }

}
// Extension pour la gestion des événements clavier
UIComponentManager.prototype.setupKeyboardEvents = function() {
    document.addEventListener('keydown', (event) => {
        // Gestion des raccourcis clavier globaux
        if (event.ctrlKey && event.key === 's') {
            event.preventDefault();
            this.saveChanges();
        }
        // Autres raccourcis clavier...
    });
};
// Extension pour la gestion des événements tactiles
UIComponentManager.prototype.setupTouchEvents = function() {
    if ('ontouchstart' in window) {
        this.delegateEvent('touchstart', '.regulation-item', this.handleTouchStart);
        this.delegateEvent('touchmove', '.regulation-item', this.handleTouchMove);
        this.delegateEvent('touchend', '.regulation-item', this.handleTouchEnd);
    }
};









// ===============================================
// INITIALISATION ET UTILISATION
// ===============================================

// Création et initialisation du gestionnaire UI
const uiManager = new UIComponentManager();

// Export pour utilisation globale
window.uiManager = uiManager;

// Écouteurs d'événements globaux
document.addEventListener('DOMContentLoaded', () => {
    uiManager.init();
});

// Gestion du redimensionnement
window.addEventListener('resize', uiManager.throttle(() => {
    uiManager.handleResize();
}, 100));



// Fonctions annexes pour la gestion des templates
function sanitizeTemplateContent(html) {
    const div = document.createElement('div');
    div.textContent = html;
    return div.innerHTML;
}

function validateTemplateStructure(template, requiredElements) {
    return requiredElements.every(selector => {
        const element = template.querySelector(selector);
        return element !== null;
    });
}


// ===============================================
// AUTRES FONCTIONS
// ===============================================


 
</script>
</body>
</html>





